Index: asterisk-11.3.0/apps/app_queue.c
===================================================================
--- asterisk-11.3.0.orig/apps/app_queue.c
+++ asterisk-11.3.0/apps/app_queue.c
@@ -402,7 +402,7 @@ ASTERISK_FILE_VERSION(__FILE__, "$Revisi
 	</application>
 	<application name="UnpauseQueueMember" language="en_US">
 		<synopsis>
-			Unpauses a queue member.		
+			Unpauses a queue member.
 		</synopsis>
 		<syntax>
 			<parameter name="queuename" />
@@ -957,6 +957,8 @@ enum queue_reload_mask {
 	QUEUE_RELOAD_MEMBER = (1 << 1),
 	QUEUE_RELOAD_RULES = (1 << 2),
 	QUEUE_RESET_STATS = (1 << 3),
+	QUEUE_RELOAD_SKILLS = (1 << 4),
+	QUEUE_RELOAD_SKILL_RULES = (1 << 5),
 };
 
 static const struct strategy {
@@ -1083,8 +1085,8 @@ enum queue_timeout_priority {
  *  q_next links ALL defined callattempt structures into a linked list. call_next is
  *  a link which allows for a subset of the callattempts to be traversed. This subset
  *  is used in wait_for_answer so that irrelevant callattempts are not traversed. This
- *  also is helpful so that queue logs are always accurate in the case where a call to 
- *  a member times out, especially if using the ringall strategy. 
+ *  also is helpful so that queue logs are always accurate in the case where a call to
+ *  a member times out, especially if using the ringall strategy.
 */
 
 struct callattempt {
@@ -1109,9 +1111,14 @@ struct callattempt {
 	struct ast_aoc_decoded *aoc_s_rate_list;
 };
 
+struct virtual_queue {
+	char id[80];                        /*!< Argument 'ruleset' to the Queue() app. */
+	int holdtime;                       /*!< Estimated Waiting Time for this virtual queue. */
+};
 
 struct queue_ent {
 	struct call_queue *parent;             /*!< What queue is our parent */
+	struct virtual_queue *vqueue;       /*!< Virtual queue in case there is skills routing */
 	char moh[MAX_MUSICCLASS];              /*!< Name of musiconhold to be used */
 	char announce[PATH_MAX];               /*!< Announcement to play for member when call is answered */
 	char context[AST_MAX_CONTEXT];         /*!< Context when user exits queue */
@@ -1131,8 +1138,11 @@ struct queue_ent {
 	int min_penalty;                       /*!< Limit the members that can take this call to this penalty or higher */
 	int linpos;                            /*!< If using linear strategy, what position are we at? */
 	int linwrapped;                        /*!< Is the linpos wrapped? */
+	char skill_ruleset[80];             /*!< Name of the skill ruleset */
+	time_t skills_next_check;              /*!< Next check of skills rules. */
 	time_t start;                          /*!< When we started holding */
 	time_t expire;                         /*!< When this entry should expire (time out of queue) */
+	struct ao2_container *mem_selection;/*!< Members who match skill rules. */
 	int cancel_answered_elsewhere;	       /*!< Whether we should force the CAE flag on this call (C) option*/
 	struct ast_channel *chan;              /*!< Our channel */
 	AST_LIST_HEAD_NOLOCK(,penalty_rule) qe_rules; /*!< Local copy of the queue's penalty rules */
@@ -1140,12 +1150,95 @@ struct queue_ent {
 	struct queue_ent *next;                /*!< The next queue entry */
 };
 
+enum skill_rule_operand_type {
+	SKILL_RULE_OPERAND_UNKNOWN,
+	SKILL_RULE_OPERAND_VARIABLE,
+	SKILL_RULE_OPERAND_VALUE,
+	SKILL_RULE_OPERAND_OPERATOR,
+};
+
+struct skill_rule_operand {
+	union {
+		char var[80];
+		int value;
+		struct skill_rule_operator* operator;
+	} u;
+	enum skill_rule_operand_type type;
+	AST_LIST_ENTRY(skill_rule_operand) entry;
+};
+
+enum skill_rule_operator_type {
+	SKILL_RULE_OPERATOR_UNKNOWN,
+	SKILL_RULE_OPERATOR_DIVISION,       /*!<  op1 / op2  */
+	SKILL_RULE_OPERATOR_MULTIPLICATION, /*!<  op1 * op2  */
+	SKILL_RULE_OPERATOR_SUBTRACTION,    /*!<  op1 - op2  */
+	SKILL_RULE_OPERATOR_ADDITION,       /*!<  op1 + op2  */
+	SKILL_RULE_OPERATOR_NOTEQUAL,       /*!<  op1 ! op2  */
+	SKILL_RULE_OPERATOR_EQUAL,          /*!<  op1 = op2  */
+	SKILL_RULE_OPERATOR_GREATER,        /*!<  op1 > op2  */
+	SKILL_RULE_OPERATOR_LESSER,         /*!<  op1 < op2  */
+	SKILL_RULE_OPERATOR_AND,            /*!<  op1 & op2  */
+	SKILL_RULE_OPERATOR_OR              /*!<  op1 | op2  */
+};
+
+#define SKILL_RULE_OPERATORS_CHARS "/*-+!=><&|"
+static enum skill_rule_operator_type skill_rule_operator_type_str[] = {
+	['/'] = SKILL_RULE_OPERATOR_DIVISION,
+	['*'] = SKILL_RULE_OPERATOR_MULTIPLICATION,
+	['-'] = SKILL_RULE_OPERATOR_SUBTRACTION,
+	['+'] = SKILL_RULE_OPERATOR_ADDITION,
+	['!'] = SKILL_RULE_OPERATOR_NOTEQUAL,
+	['='] = SKILL_RULE_OPERATOR_EQUAL,
+	['>'] = SKILL_RULE_OPERATOR_GREATER,
+	['<'] = SKILL_RULE_OPERATOR_LESSER,
+	['&'] = SKILL_RULE_OPERATOR_AND,
+	['|'] = SKILL_RULE_OPERATOR_OR,
+};
+
+struct skill_rule_operator {
+	struct skill_rule_operator *parent;
+	AST_LIST_HEAD_NOLOCK(,skill_rule_operand) operands;
+	enum skill_rule_operator_type type;
+};
+
+struct skill_rule {
+	struct skill_rule_operator *dcond;           /*!< Condition against dynamical variables */
+	struct skill_rule_operator *cond;            /*!< Condition against skills */
+};
+
+struct skill_ruleset {
+	char name[80];
+	struct ao2_container *rules;
+	AST_LIST_ENTRY(skill_ruleset) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skill_rulesets, skill_ruleset);
+
+struct rule_var {
+	char name[80];
+	char value[80];
+};
+
+struct skill {
+	char name[80];                      /*!< Name of skill */
+	int weight;                         /*!< Weight */
+};
+
+struct skills_group {
+	char name[80];
+	struct ao2_container *skills;       /*!< Head of the list of skills */
+	AST_LIST_ENTRY(skills_group) entry;
+};
+
+static AST_LIST_HEAD_STATIC(skills_groups, skills_group);
+
 struct member {
 	char interface[AST_CHANNEL_NAME];    /*!< Technology/Location to dial to reach this member*/
 	char state_exten[AST_MAX_EXTENSION]; /*!< Extension to get state from (if using hint) */
 	char state_context[AST_MAX_CONTEXT]; /*!< Context to use when getting state (if using hint) */
 	char state_interface[AST_CHANNEL_NAME]; /*!< Technology/Location from which to read devicestate changes */
 	char membername[80];                 /*!< Member name to use in queue logs */
+	char skills[80];                     /*!< Member skills */
 	int penalty;                         /*!< Are we a last resort? */
 	int calls;                           /*!< Number of calls serviced by this member */
 	int dynamic;                         /*!< Are we dynamically added? */
@@ -1153,6 +1246,7 @@ struct member {
 	int status;                          /*!< Status of queue member */
 	int paused;                          /*!< Are we paused (not accepting calls)? */
 	int queuepos;                        /*!< In what order (pertains to certain strategies) should this member be called? */
+	int holdtime;                        /*!< Average holdtime. */
 	time_t lastcall;                     /*!< When last successful call was hungup */
 	struct call_queue *lastqueue;	     /*!< Last queue we received a call */
 	unsigned int dead:1;                 /*!< Used to detect members deleted in realtime */
@@ -1291,7 +1385,8 @@ struct call_queue {
 	int rrpos;                          /*!< Round Robin - position */
 	int memberdelay;                    /*!< Seconds to delay connecting member to caller */
 	int autofill;                       /*!< Ignore the head call status and ring an available agent */
-	
+
+	struct ao2_container *vqueues;      /*!< Virtual queues */
 	struct ao2_container *members;             /*!< Head of the list of members */
 	struct queue_ent *head;             /*!< Head of the list of callers */
 	AST_LIST_ENTRY(call_queue) list;    /*!< Next call queue */
@@ -1313,6 +1408,8 @@ static struct member *interface_exists(s
 static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused);
 
 static void queue_transfer_fixup(void *data, struct ast_channel *old_chan, struct ast_channel *new_chan);
+static int update_queue_ent_skills_next_check(struct call_queue *q);
+static int member_is_selected(struct queue_ent *qe, struct member *mem);
 
 static struct member *find_member_by_queuename_and_interface(const char *queuename, const char *interface);
 /*! \brief sets the QUEUESTATUS channel variable */
@@ -1503,8 +1600,8 @@ static void set_queue_variables(struct c
 			q->name, q->maxlen, int2strat(q->strategy), q->count, q->holdtime, q->talktime, q->callscompleted, q->callsabandoned,  q->servicelevel, sl);
 
 		ao2_unlock(q);
-	
-		pbx_builtin_setvar_multiple(chan, interfacevar); 
+
+		pbx_builtin_setvar_multiple(chan, interfacevar);
 	} else {
 		ao2_unlock(q);
 	}
@@ -1541,7 +1638,9 @@ static inline void insert_entry(struct c
  * is available, the function immediately returns 0. If no members are available,
  * then -1 is returned.
  */
-static int get_member_status(struct call_queue *q, int max_penalty, int min_penalty, enum empty_conditions conditions)
+
+//FIXME: qe isn't used. Remove from argument list ?
+static int get_member_status(struct call_queue *q, int max_penalty, int min_penalty, enum empty_conditions conditions, struct queue_ent* qe)
 {
 	struct member *member;
 	struct ao2_iterator mem_iter;
@@ -1556,6 +1655,11 @@ static int get_member_status(struct call
 			}
 		}
 
+		if (qe && !member_is_selected(qe, member)) {
+			ast_debug(4, "%s is unavailable because it is not selected by rule '%s'\n", member->membername, qe->skill_ruleset);
+			continue;
+		}
+
 		switch (member->status) {
 		case AST_DEVICE_INVALID:
 			if (conditions & QUEUE_EMPTY_INVALID) {
@@ -1685,6 +1789,8 @@ static int update_status(struct call_que
 		</syntax>
 	</managerEventInstance>
 	***/
+
+	update_queue_ent_skills_next_check(q);
 	manager_event(EVENT_FLAG_AGENT, "QueueMemberStatus",
 		"Queue: %s\r\n"
 		"Location: %s\r\n"
@@ -1695,9 +1801,10 @@ static int update_status(struct call_que
 		"CallsTaken: %d\r\n"
 		"LastCall: %d\r\n"
 		"Status: %d\r\n"
-		"Paused: %d\r\n",
+		"Paused: %d\r\n"
+		"Skills: %s\r\n",
 		q->name, m->interface, m->membername, m->state_interface, m->dynamic ? "dynamic" : m->realtime ? "realtime" : "static",
-		m->penalty, m->calls, (int)m->lastcall, m->status, m->paused
+		m->penalty, m->calls, (int)m->lastcall, m->status, m->paused, m->skills
 	);
 
 	return 0;
@@ -1708,7 +1815,7 @@ static int update_status(struct call_que
  * \retval 1 if the member is available
  * \retval 0 if the member is not available
  */
-static int is_member_available(struct member *mem)
+static int is_member_available(struct member *mem, struct queue_ent *qe)
 {
 	int available = 0;
 
@@ -1727,7 +1834,8 @@ static int is_member_available(struct me
 			/* else fall through */
 		case AST_DEVICE_NOT_INUSE:
 		case AST_DEVICE_UNKNOWN:
-			if (!mem->paused) {
+			if (!mem->paused &&
+			    (!qe || member_is_selected(qe, mem))) {
 				available = 1;
 			}
 			break;
@@ -1773,7 +1881,7 @@ static int handle_statechange(void *data
 
 			/* check every member until we find one NOT_INUSE */
 			if (!avail) {
-				avail = is_member_available(m);
+				avail = is_member_available(m, NULL);
 			}
 			if (avail && found_member) {
 				/* early exit as we've found an available member and the member of interest */
@@ -1916,7 +2024,7 @@ static int get_queue_member_status(struc
 }
 
 /*! \brief allocate space for new queue member and set fields based on parameters passed */
-static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int ringinuse)
+static struct member *create_queue_member(const char *interface, const char *membername, int penalty, int paused, const char *state_interface, int ringinuse, const char *skills)
 {
 	struct member *cur;
 
@@ -1946,6 +2054,10 @@ static struct member *create_queue_membe
 			ast_copy_string(cur->state_context, S_OR(context, "default"), sizeof(cur->state_context));
 		}
 		cur->status = get_queue_member_status(cur);
+		if (!ast_strlen_zero(skills))
+			ast_copy_string(cur->skills, skills, sizeof(cur->skills));
+		else
+			cur->skills[0] = '\0';
 	}
 
 	return cur;
@@ -1958,7 +2070,7 @@ static int compress_char(const char c)
 		return 0;
 	} else if (c > 96) {
 		return c - 64;
-	} 
+	}
 	return c - 32;
 }
 
@@ -2121,7 +2233,7 @@ static int insert_penaltychange(const ch
 	}
 
 	contentdup = ast_strdupa(content);
-	
+
 	if (!(maxstr = strchr(contentdup, ','))) {
 		ast_log(LOG_WARNING, "Improperly formatted penaltychange rule at line %d. Ignoring.\n", linenum);
 		ast_free(rule);
@@ -2142,7 +2254,7 @@ static int insert_penaltychange(const ch
 	if ((minstr = strchr(maxstr,','))) {
 		*minstr++ = '\0';
 	}
-	
+
 	/* The last check will evaluate true if either no penalty change is indicated for a given rule
 	 * OR if a min penalty change is indicated but no max penalty change is */
 	if (*maxstr == '+' || *maxstr == '-' || *maxstr == '\0') {
@@ -2174,7 +2286,7 @@ static int insert_penaltychange(const ch
 			}
 		}
 		AST_LIST_TRAVERSE_SAFE_END;
-	
+
 		if (!inserted) {
 			AST_LIST_INSERT_TAIL(&rl_iter->rules, rule, list);
 			inserted = 1;
@@ -2227,7 +2339,7 @@ static void parse_empty_options(const ch
 }
 
 /*! \brief Configure a queue parameter.
- * 
+ *
  * The failunknown flag is set for config files (and static realtime) to show
  * errors for unknown parameters. It is cleared for dynamic realtime to allow
  *  extra fields in the tables.
@@ -2236,7 +2348,7 @@ static void parse_empty_options(const ch
 */
 static void queue_set_param(struct call_queue *q, const char *param, const char *val, int linenum, int failunknown)
 {
-	if (!strcasecmp(param, "musicclass") || 
+	if (!strcasecmp(param, "musicclass") ||
 		!strcasecmp(param, "music") || !strcasecmp(param, "musiconhold")) {
 		ast_string_field_set(q, moh, val);
 	} else if (!strcasecmp(param, "announce")) {
@@ -2492,6 +2604,7 @@ static void rt_handle_member_record(stru
 	const char *state_interface = S_OR(ast_variable_retrieve(member_config, interface, "state_interface"), interface);
 	const char *penalty_str = ast_variable_retrieve(member_config, interface, "penalty");
 	const char *paused_str = ast_variable_retrieve(member_config, interface, "paused");
+    const char *skills_str = ast_variable_retrieve(member_config, interface, "skills");
 
 	if (ast_strlen_zero(rt_uniqueid)) {
 		ast_log(LOG_WARNING, "Realtime field uniqueid is empty for member %s\n", S_OR(membername, "NULL"));
@@ -2537,9 +2650,15 @@ static void rt_handle_member_record(stru
 				ast_copy_string(m->state_interface, state_interface, sizeof(m->state_interface));
 			}
 			m->penalty = penalty;
+ 			if (!ast_strlen_zero(skills_str)) {
+ 				ast_copy_string(m->skills, skills_str, sizeof(m->skills));
+            } else {
+ 				m->skills[0] = '\0';
+            }
 			m->ringinuse = ringinuse;
 			found = 1;
 			ao2_ref(m, -1);
+ 			update_queue_ent_skills_next_check(q);
 			break;
 		}
 		ao2_ref(m, -1);
@@ -2548,9 +2667,10 @@ static void rt_handle_member_record(stru
 
 	/* Create a new member */
 	if (!found) {
-		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, ringinuse))) {
+		if ((m = create_queue_member(interface, membername, penalty, paused, state_interface, ringinuse, skills_str))) {
 			m->dead = 0;
 			m->realtime = 1;
+			update_queue_ent_skills_next_check(q);
 			ast_copy_string(m->rt_uniqueid, rt_uniqueid, sizeof(m->rt_uniqueid));
 			if (!log_membername_as_agent) {
 				ast_queue_log(q->name, "REALTIME", m->interface, "ADDMEMBER", "%s", paused ? "PAUSED" : "");
@@ -2594,6 +2714,10 @@ static void destroy_queue(void *obj)
 		}
 	}
 	ao2_ref(q->members, -1);
+
+	if (q->vqueues) {
+		ao2_ref(q->vqueues, -1);
+	}
 }
 
 static struct call_queue *alloc_queue(const char *queuename)
@@ -2641,7 +2765,7 @@ static struct call_queue *find_queue_by_
 				ao2_unlock(q);
 				queue_t_unref(q, "Queue is dead; can't return it");
 				return NULL;
-			} 
+			}
 			ast_log(LOG_WARNING, "Static queue '%s' already exists. Not loading from realtime\n", q->name);
 			ao2_unlock(q);
 			return q;
@@ -2859,38 +2983,921 @@ static void update_realtime_members(stru
 		return;
 	}
 
-	ao2_lock(q);
+	ao2_lock(q);
+
+	/* Temporarily set realtime  members dead so we can detect deleted ones.*/
+	mem_iter = ao2_iterator_init(q->members, 0);
+	while ((m = ao2_iterator_next(&mem_iter))) {
+		if (m->realtime) {
+			m->dead = 1;
+		}
+		ao2_ref(m, -1);
+	}
+	ao2_iterator_destroy(&mem_iter);
+
+	while ((interface = ast_category_browse(member_config, interface))) {
+		rt_handle_member_record(q, interface, member_config);
+	}
+
+	/* Delete all realtime members that have been deleted in DB. */
+	mem_iter = ao2_iterator_init(q->members, 0);
+	while ((m = ao2_iterator_next(&mem_iter))) {
+		if (m->dead) {
+			if (ast_strlen_zero(m->membername) || !log_membername_as_agent) {
+				ast_queue_log(q->name, "REALTIME", m->interface, "REMOVEMEMBER", "%s", "");
+			} else {
+				ast_queue_log(q->name, "REALTIME", m->membername, "REMOVEMEMBER", "%s", "");
+			}
+			member_remove_from_queue(q, m);
+		}
+		ao2_ref(m, -1);
+	}
+	ao2_iterator_destroy(&mem_iter);
+	ao2_unlock(q);
+	ast_config_destroy(member_config);
+}
+
+static void destroy_skills_group(void *obj)
+{
+	struct skills_group *skgrp = obj;
+	struct skill *cur;
+	struct ao2_iterator sk_iter = ao2_iterator_init(skgrp->skills, 0);
+
+	while ((cur = ao2_iterator_next(&sk_iter))) {
+		ao2_unlink(skgrp->skills, cur);
+		ao2_ref(cur, -1);
+	}
+	ao2_iterator_destroy(&sk_iter);
+	ao2_ref(skgrp->skills, -1);
+}
+
+static void destroy_operator(struct skill_rule_operator *op)
+{
+	struct skill_rule_operand *operand;
+
+	if (!op)
+		return;
+
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&op->operands, operand, entry) {
+		AST_LIST_REMOVE_CURRENT(entry);
+		if (operand->type == SKILL_RULE_OPERAND_OPERATOR)
+			destroy_operator(operand->u.operator);
+
+		ast_free(operand);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+	ast_free(op);
+}
+
+static void destroy_skill_rule(void* obj)
+{
+	struct skill_rule* r = obj;
+	if (r->dcond)
+		destroy_operator(r->dcond);
+	if (r->cond)
+		destroy_operator(r->cond);
+}
+
+static void destroy_skill_ruleset(void *obj)
+{
+	struct skill_ruleset *ruleset = obj;
+	struct skill_rule *cur;
+	struct ao2_iterator rule_iter = ao2_iterator_init(ruleset->rules, 0);
+
+	while ((cur = ao2_iterator_next(&rule_iter))) {
+		ao2_unlink(ruleset->rules, cur);
+		ao2_ref(cur, -1);
+	}
+	ao2_iterator_destroy(&rule_iter);
+	ao2_ref(ruleset->rules, -1);
+}
+
+static struct skill_rule_operator *create_skill_rule_operator(enum skill_rule_operator_type t, struct skill_rule_operator *parent)
+{
+	struct skill_rule_operator *op;
+	op = ast_calloc(1, sizeof(*op));
+	if (!op)
+		return NULL;
+
+	op->type = t;
+	AST_LIST_HEAD_INIT_NOLOCK(&op->operands);
+	op->parent = parent;
+
+	return op;
+}
+
+static struct skill_rule_operand *create_skill_rule_operand(enum skill_rule_operand_type t)
+{
+	struct skill_rule_operand *operand;
+	operand = ast_calloc(1, sizeof(*operand));
+	if (!operand)
+		return NULL;
+
+	operand->type = t;
+	return operand;
+}
+
+static char* display_operator(struct skill_rule_operator *op)
+{
+	struct skill_rule_operand *operand;
+	size_t len = 512;
+	char *str = malloc(len);
+	char *s = str;
+
+	*str = '\0';
+	AST_LIST_TRAVERSE(&op->operands, operand, entry) {
+		char t;
+		switch(op->type) {
+		case SKILL_RULE_OPERATOR_NOTEQUAL: t = '!'; break;
+		case SKILL_RULE_OPERATOR_EQUAL:    t = '='; break;
+		case SKILL_RULE_OPERATOR_GREATER:  t = '>'; break;
+		case SKILL_RULE_OPERATOR_LESSER:   t = '<'; break;
+		case SKILL_RULE_OPERATOR_AND:      t = '&'; break;
+		case SKILL_RULE_OPERATOR_OR:       t = '|'; break;
+		default:                           t = '?'; break;
+		}
+
+		if (*str != '\0')
+			ast_build_string(&s, &len, "%c", t);
+
+		switch(operand->type) {
+		case SKILL_RULE_OPERAND_VARIABLE:
+			ast_build_string(&s, &len, "%s", operand->u.var);
+			break;
+		case SKILL_RULE_OPERAND_VALUE:
+			ast_build_string(&s, &len, "%d", operand->u.value);
+			break;
+		case SKILL_RULE_OPERAND_OPERATOR:
+		{
+			char *tmp = display_operator(operand->u.operator);
+			ast_build_string(&s, &len, "(%s)", tmp);
+			free(tmp);
+			break;
+		}
+		case SKILL_RULE_OPERAND_UNKNOWN:
+			ast_build_string(&s, &len, "<unknown>");
+		}
+	}
+	return str;
+}
+
+static struct skill_rule_operator* parse_expr(const char *expr)
+{
+	struct skill_rule_operator *op, *head;
+	struct skill_rule_operand *operand = NULL;
+	const char *ptr, *start = NULL;
+
+	op = create_skill_rule_operator(SKILL_RULE_OPERATOR_UNKNOWN, NULL);
+	if (!op)
+		return NULL;
+
+	head = op;
+	ptr = expr;
+	do {
+		if (start) {
+			/* currently parsing a variable name. */
+			if ((*ptr >= 'a' && *ptr <= 'z') ||
+			    (*ptr >= 'A' && *ptr <= 'Z') ||
+			    (*ptr >= '0' && *ptr <= '9') ||
+			    (*ptr != '\0' && strchr("$-_", *ptr))) {
+				++ptr;
+				continue;
+			}
+
+			if (operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, missing operator.\n");
+				goto error;
+			}
+
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_VARIABLE);
+			if (!operand) {
+				/* OOM */
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+				goto error;
+			}
+			ast_copy_string(operand->u.var, start, (ptr + 1 - start) > sizeof(operand->u.var)
+			                                                         ? sizeof(operand->u.var)
+			                                                         : (ptr + 1 - start));
+			start = NULL;
+		}
+		if ((*ptr >= 'a' && *ptr <= 'z') ||
+		    (*ptr >= 'A' && *ptr <= 'Z') ||
+		    *ptr == '$') {
+			/* starting to parse a variable name. */
+			start = ptr++;
+			continue;
+		}
+		if ((*ptr >= '0' && *ptr <= '9') || *ptr == '-') {
+			/* parsing an integer value. */
+			int value;
+			start = ptr;
+			errno = 0;
+			value = strtol(start, (char**)&ptr, 10);
+			if (start == ptr) {
+				/* no digits found */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no-digits.\n");
+				goto error;
+			}
+			if ((errno == ERANGE && (value == LONG_MAX || value == LONG_MIN)) ||
+			    (errno != 0 && value == 0)) {
+				/* error */
+				ast_log(LOG_ERROR, "Unable to parse rule: strtol error: %s.\n", strerror(errno));
+				goto error;
+			}
+
+			if (operand) {
+				/* WTF syn error */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, missing operator.\n");
+				goto error;
+			}
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_VALUE);
+			if (!operand) {
+				/* OOM */
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+				goto error;
+			}
+			operand->u.value = value;
+			start = NULL;
+			continue;
+		}
+		if (*ptr == '(') {
+			struct skill_rule_operator *newop;
+			const char *end;
+			char *tmp;
+			unsigned count = 0;
+
+			if (operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: missing operator before '('\n");
+				goto error;
+			}
+
+			start = ++ptr;
+			end = ptr + strlen(ptr);
+
+			/* Look for the closing bracket. */
+			while (ptr < end && (count > 0 || *ptr != ')'))
+				switch(*ptr++) {
+				case '(': count++; break;
+				case ')': count--; break;
+				}
+
+			if (ptr == start) {
+				ast_log(LOG_ERROR, "Unable to parse rule: empty expression between ()\n");
+				goto error;
+			}
+			if (ptr == end) {
+				ast_log(LOG_ERROR, "Unable to parse rule: missing ')'\n");
+				goto error;
+			}
+
+			tmp = ast_strndup(start, ptr-start);
+			newop = parse_expr(tmp);
+			ast_free(tmp);
+
+			if (!newop) {
+				/* Something failed while parsing subexpr. Do
+				 * not display any message as parse_expr()
+				 * probably dit it.
+				 */
+				goto error;
+			}
+
+			operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+			if (!operand) {
+				ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory\n");
+				ast_free(newop);
+				goto error;
+			}
+			operand->u.operator = newop;
+			start = NULL;
+			++ptr;
+		}
+		/* if *ptr == '\0', strchr("...", *ptr) != NULL */
+		if (strchr(SKILL_RULE_OPERATORS_CHARS, *ptr)) {
+			/* operator */
+			enum skill_rule_operator_type flag = SKILL_RULE_OPERATOR_UNKNOWN;
+
+			if (!operand) {
+				/* syntax error */
+				ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no operand before '%c'.\n", *ptr ? *ptr : ';');
+				goto error;
+			}
+
+			if (*ptr != '\0')
+				flag = skill_rule_operator_type_str[(size_t)*ptr];
+			else
+				flag = op->type;
+
+			if (op->type == SKILL_RULE_OPERATOR_UNKNOWN) {
+				if (flag == SKILL_RULE_OPERATOR_UNKNOWN) {
+					/* syntax error */
+					ast_log(LOG_ERROR, "Unable to parse rule: syntax error, no operator.\n");
+					goto error;
+				}
+				op->type = flag;
+			}
+
+			if (op->type < flag) {
+				/* last operator has a greater priority than current operator. */
+				struct skill_rule_operator *parent;
+
+				/* Firstly, add the operand in the current operator. */
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+
+				/* Then we try to jump to an upper operator, or to create one. */
+
+				/* look for a parent operator with a lower or equal priority. */
+				for(parent = op->parent; parent && parent->type < flag; parent = parent->parent)
+					op = parent;
+
+				if (!parent) {
+					/* There isn't any other operator with a lower or equal priority */
+					parent = create_skill_rule_operator(flag, NULL);
+					if (!parent) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+
+					operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+					if (!operand) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						ast_free(parent);
+						goto error;
+					}
+					operand->u.operator = op;
+
+					op->parent = parent;
+					AST_LIST_INSERT_TAIL(&parent->operands, operand, entry);
+
+					head = parent;
+
+					operand = NULL;
+				} else if (parent->type > flag) {
+					/* There is an operator with a greater priority, so we insert this
+					 * operator between this one and his last child. */
+					struct skill_rule_operator *newop;
+					newop = create_skill_rule_operator(flag, parent);
+					if (!newop) {
+						/* OOM */
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+
+					AST_LIST_TRAVERSE(&parent->operands, operand, entry) {
+						if (operand->type == SKILL_RULE_OPERAND_OPERATOR && operand->u.operator == op)
+							break;
+					}
+
+					if (!operand) {
+						/* WTF */
+						ast_free(newop);
+						ast_log(LOG_ERROR, "Unable to parse rule: internal error (unable to find operand).\n");
+						goto error;
+					}
+					op->parent = newop;
+
+					AST_LIST_REMOVE(&parent->operands, operand, entry);
+					AST_LIST_INSERT_TAIL(&newop->operands, operand, entry);
+					operand = NULL;
+
+					operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+					if (!operand) {
+						/* OOM */
+						ast_free(newop);
+						ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+						goto error;
+					}
+					operand->u.operator = newop;
+					AST_LIST_INSERT_TAIL(&parent->operands, operand, entry);
+
+					operand = NULL;
+
+					parent = newop;
+				}
+				op = parent;
+
+			} else if (op->type > flag) {
+				/* last operator has a lower priority than current operator. */
+				struct skill_rule_operator *newop;
+				newop = create_skill_rule_operator(flag, op);
+				if (!newop) {
+					/* OOM */
+					ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+					goto error;
+				}
+
+				AST_LIST_INSERT_TAIL(&newop->operands, operand, entry);
+				operand = NULL;
+
+				operand = create_skill_rule_operand(SKILL_RULE_OPERAND_OPERATOR);
+				if (!operand) {
+					/* OOM */
+					ast_log(LOG_ERROR, "Unable to parse rule: out-of-memory.\n");
+					ast_free(newop);
+					goto error;
+				}
+				operand->u.operator = newop;
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+
+				op = newop;
+			} else {
+				AST_LIST_INSERT_TAIL(&op->operands, operand, entry);
+				operand = NULL;
+			}
+		}
+
+		++ptr;
+	} while (*(ptr-1));
+
+	return head;
+
+error:
+	destroy_operator(head);
+	if(operand)
+		ast_free(operand);
+	return NULL;
+}
+
+static int parse_skill_rule(struct skill_rule *r, const char *line)
+{
+	char* dcond = ast_strdupa(line);
+	char* cond;
+
+	cond = strchr(dcond, ',');
+	if (cond) {
+		*cond++ = '\0';
+		r->dcond = parse_expr(dcond);
+	}
+	else
+		cond = dcond;
+
+	r->cond = parse_expr(cond);
+	return 0;
+}
+
+static int operator_eval(struct skill_rule_operator *op, struct ao2_container *variables, struct ast_channel* chan,
+                         int (*getvalue_fn) (const char* key, void* data), void* data,
+                         void (*operator_proceeded_cb) (const char* left_name, int left_value, enum skill_rule_operator_type operator, const char* right_name, int right_value, void* data))
+{
+	struct skill_rule_operand *opnd = NULL;
+	int ret = 0;
+	const char* last_name = NULL;
+	int first = 1;
+
+	if (!op) {
+		ast_log(LOG_WARNING, "Rule is empty\n");
+		return 0;
+	}
+
+	AST_LIST_TRAVERSE(&op->operands, opnd, entry) {
+		const char *name = NULL;
+		int value = 0;
+		switch(opnd->type) {
+			case SKILL_RULE_OPERAND_VARIABLE:
+			{
+				struct rule_var *var = NULL;
+				name = opnd->u.var;
+
+				if (*name == '$') {
+					++name;
+
+					/* This is a meta-variable, find the value in the variables list. */
+					if (variables != NULL) {
+						struct ao2_iterator variter = ao2_iterator_init(variables, 0);
+
+						while ((var = ao2_iterator_next(&variter)) && strcmp(name, var->name))
+							ao2_ref(var, -1);
+
+						if (var)
+							name = var->value;
+
+						ao2_iterator_destroy(&variter);
+					}
+
+					/* If doesn't found in variables list, try with env vars */
+					if (!var && chan != NULL)
+						name = pbx_builtin_getvar_helper(chan, name);
+				}
+
+				if (name) {
+					char *endptr = NULL;
+					int v = strtoul(name, &endptr, 10);
+
+					if (endptr == '\0') {
+						value = v; /* name is an integer, so that's the value. */
+					} else if (getvalue_fn) {
+						/* Use callback to get the value of this variable. */
+						value = getvalue_fn(name, data);
+					} else {
+						ast_log(LOG_ERROR, "There is no 'getvalue' callback defined");
+					}
+				}
+
+				if (var)
+					ao2_ref(var, -1);
+				break;
+			}
+			case SKILL_RULE_OPERAND_VALUE:
+				value = opnd->u.value;
+				break;
+			case SKILL_RULE_OPERAND_OPERATOR:
+				value = operator_eval(opnd->u.operator, variables, chan, getvalue_fn, data, operator_proceeded_cb);
+				break;
+			case SKILL_RULE_OPERAND_UNKNOWN:
+				/* WTF */
+				return 0;
+		}
+
+		if (first)
+			ret = value;
+		else {
+			if (operator_proceeded_cb)
+				operator_proceeded_cb(last_name, ret, op->type, name, value, data);
+
+			switch(op->type) {
+				case SKILL_RULE_OPERATOR_DIVISION:
+					if (value != 0)
+						ret /= value;
+					else {
+						ast_log(LOG_WARNING, "Rule error: division by zero.\n");
+						return 0;
+					}
+					break;
+				case SKILL_RULE_OPERATOR_MULTIPLICATION:
+					ret *= value;
+					break;
+				case SKILL_RULE_OPERATOR_SUBTRACTION:
+					ret -= value;
+					break;
+				case SKILL_RULE_OPERATOR_ADDITION:
+					ret += value;
+					break;
+				case SKILL_RULE_OPERATOR_NOTEQUAL:
+					ret = (ret != value);
+					break;
+				case SKILL_RULE_OPERATOR_EQUAL:
+					ret = (ret == value);
+					break;
+				case SKILL_RULE_OPERATOR_GREATER:
+					ret = (ret > value);
+					break;
+				case SKILL_RULE_OPERATOR_LESSER:
+					ret = (ret < value);
+					break;
+				case SKILL_RULE_OPERATOR_AND:
+					ret = (ret && value);
+					break;
+				case SKILL_RULE_OPERATOR_OR:
+					ret = (ret || value);
+					break;
+				case SKILL_RULE_OPERATOR_UNKNOWN:
+					/* WTF */
+					return 0;
+			}
+		}
+
+		first = 0;
+		last_name = name;
+	}
+
+	return ret;
+}
+
+static int operator_eval_skills_getvalue(const char *key, void* data)
+{
+	struct skills_group *skills = data;
+	int value = 0;
+	struct skill* skill;
+	struct ao2_iterator iter = ao2_iterator_init(skills->skills, 0);
+	while ((skill = ao2_iterator_next(&iter)) && strcasecmp(skill->name, key))
+		ao2_ref(skill, -1);
+
+	if (!skill)
+		value = 0;
+	else {
+		value = skill->weight;
+		ao2_ref(skill, -1);
+	}
+	ao2_iterator_destroy(&iter);
+	return value;
+}
+
+static int operator_eval_skills(struct skill_rule_operator *op, struct skills_group *skills, struct ao2_container *variables, struct queue_ent *qe)
+{
+	return operator_eval(op, variables, qe->chan, operator_eval_skills_getvalue, skills, NULL);
+}
+
+static int calculate_estimated_waiting_time(struct queue_ent *qe)
+{
+	struct ao2_iterator iter;
+	struct member *mem;
+	struct queue_ent *ch;
+	int sum = 0, count = 0;
+	float aht, ciqu = 0;
+	float ali;
+
+	if (!qe->mem_selection || ao2_container_count(qe->mem_selection) == 0)
+		return qe->vqueue->holdtime;
+
+	iter = ao2_iterator_init(qe->mem_selection, 0);
+	while ((mem = ao2_iterator_next(&iter))) {
+		sum += mem->holdtime;
+		count++;
+		ao2_ref(mem, -1);
+	}
+	ao2_iterator_destroy(&iter);
+
+	ali = count > 0 ? count : 0.0001;
+	aht = sum / ali;
+
+	for (ch = qe->parent->head; ch; ch = ch->next) {
+		if (!ch->pending && ch->vqueue == qe->vqueue)
+			ciqu++;
+	}
+
+	return (qe->vqueue->holdtime = aht * ciqu / ali);
+}
+
+static int get_estimated_waiting_time(struct queue_ent *qe)
+{
+	if (qe->vqueue)
+		return calculate_estimated_waiting_time(qe);
+	else
+		return qe->parent->holdtime;
+}
+
+static int get_waiting_time(struct queue_ent *qe)
+{
+	return time(NULL) - qe->start;
+}
+
+static int operator_eval_dynamics_getvalue(const char *key, void* data)
+{
+	static const struct {
+		const char *name;
+		int (*func) (struct queue_ent *qe);
+	} static_vars[] = {
+		{ "EWT", get_estimated_waiting_time },
+		{ "WT", get_waiting_time },
+	};
+	struct queue_ent* qe = data;
+	size_t i;
+	int value = 0;
+
+	for (i = 0; i < sizeof(static_vars) / sizeof(*static_vars) && strcasecmp(static_vars[i].name, key); ++i)
+		;
+
+	if (i < (sizeof(static_vars) / sizeof(*static_vars)))
+		value = static_vars[i].func(qe);
+
+	return value;
+}
+
+static void operator_eval_dynamics_proceed_cb(const char *left_name, int left_value, enum skill_rule_operator_type op,
+                                              const char *right_name, int right_value, void* data)
+{
+	struct queue_ent* qe = data;
+	int left_wt = left_name && !strcasecmp(left_name, "WT");
+	int right_wt = right_name && !strcasecmp(right_name, "WT");
+	int new_check = 0;
+
+	if (left_wt && right_wt) {
+		/* WTF */
+		return;
+	}
+
+	switch(op)
+	{
+	case SKILL_RULE_OPERATOR_EQUAL:
+		if (left_wt)
+			new_check = time(NULL) + right_value - get_waiting_time(qe);
+		if (right_wt)
+			new_check = time(NULL) + left_value - get_waiting_time(qe);
+
+		break;
+	case SKILL_RULE_OPERATOR_GREATER:
+		if (right_wt)
+			new_check = time(NULL) + left_value - get_waiting_time(qe);
+		break;
+	case SKILL_RULE_OPERATOR_LESSER:
+		if (left_wt)
+			new_check = time(NULL) + right_value - get_waiting_time(qe);
+		break;
+	case SKILL_RULE_OPERATOR_DIVISION:
+	case SKILL_RULE_OPERATOR_MULTIPLICATION:
+	case SKILL_RULE_OPERATOR_SUBTRACTION:
+	case SKILL_RULE_OPERATOR_ADDITION:
+	case SKILL_RULE_OPERATOR_NOTEQUAL:
+	case SKILL_RULE_OPERATOR_AND:
+	case SKILL_RULE_OPERATOR_OR:
+	case SKILL_RULE_OPERATOR_UNKNOWN:
+		break;
+	}
+	if (new_check && (!qe->skills_next_check || qe->skills_next_check > new_check)) {
+		qe->skills_next_check = new_check;
+	}
+}
+
+static int operator_eval_dynamics(struct skill_rule_operator *op, struct ao2_container* variables, struct queue_ent* qe)
+{
+	return operator_eval(op, variables, qe->chan, operator_eval_dynamics_getvalue, qe, operator_eval_dynamics_proceed_cb);
+}
+
+/** Syntax of a rule name with their arguments: Rule(arg1=value1^arg2=value2^...)
+ *
+ * This function returns a container of 'struct rule_var' with every variables,
+ * and rulename value is set to the real rulename.
+ */
+static struct ao2_container *get_rule_variables(struct queue_ent *qe, char **rulename)
+{
+	char *ptr, *var;
+	struct rule_var *v;
+	struct ao2_container *variables = ao2_container_alloc(37, NULL, NULL);
+
+	if (!variables) {
+		return NULL;
+	}
+
+	if (!(ptr = strchr(*rulename, '(')))
+		return variables;
+
+	*ptr++ = '\0';
+	while ((var = strsep(&ptr, ",|^)"))) {
+		char *value = strchr(var, '=');
+
+		if (!value)
+			continue;
+
+		*value++ = '\0';
+		v = ao2_alloc(sizeof(*v), NULL);
+		if (!v)
+			break;
+		ast_copy_string(v->name, var, sizeof(v->name));
+		ast_copy_string(v->value, value, sizeof(v->value));
+		ao2_link(variables, v);
+		ao2_ref(v, -1);
+	}
+
+	return variables;
+}
+
+static int member_is_selected(struct queue_ent *qe, struct member *mem)
+{
+	struct member *m;
+
+	/* If there isn't any queue entry or if there isn't any ruleset on the
+	 * queue, it's because he doesn't use the skills routing.
+	 */
+	if (!qe || ast_strlen_zero(qe->skill_ruleset))
+		return 1;
+
+	/* No member is selected. */
+	if (!qe->mem_selection)
+		return 0;
+
+	m = ao2_find(qe->mem_selection, mem, OBJ_POINTER);
+
+	if (m)
+		ao2_ref(m, -1);
+
+	return m != NULL;
+}
+
+static int join_virtual_queue(struct call_queue *q, struct queue_ent *qe)
+{
+	struct virtual_queue *vq = NULL;
+
+	if (!q->vqueues) {
+		q->vqueues = ao2_container_alloc(37, NULL, NULL);
+		if (!q->vqueues)
+			return -1;
+	} else {
+		struct ao2_iterator iter;
+
+		iter = ao2_iterator_init(q->vqueues, 0);
+		while ((vq = ao2_iterator_next(&iter)) && strcmp(vq->id, qe->skill_ruleset))
+			ao2_ref(vq, -1);
+		ao2_iterator_destroy(&iter);
+	}
+
+	if (!vq) {
+		vq = ao2_alloc(sizeof(*vq), NULL);
+		if (!vq)
+			return -1;
+		ast_copy_string(vq->id, qe->skill_ruleset, sizeof(vq->id));
+		ao2_link(q->vqueues, vq);
+	}
+
+	qe->vqueue = vq;
+	/* do not unref vq because it's keept by the queue entry. */
+
+	return 0;
+}
+
+/* Use rules to search members from the queue_ent's skills.
+ *
+ * Returns -1 when an error is occured.
+ * Returns 0 when agents are selected.
+ * Returns 1 when the ruleset matches no agent.
+ */
+static int select_members_from_skills(struct queue_ent *qe)
+{
+	int res;
+	struct call_queue* q = qe->parent;
+	struct member *member;
+	struct ao2_container *variables;
+	struct skill_ruleset* rs;
+	struct skill_rule* rule;
+	struct ao2_iterator rule_iter, mem_iter;
+	char* ruleset_name;
+
+	qe->skills_next_check = 0;
+
+	if (ast_strlen_zero(qe->skill_ruleset))
+		return 0;
+
+	ruleset_name = ast_strdupa(qe->skill_ruleset);
+	variables = get_rule_variables(qe, &ruleset_name);
+
+	if (!variables)
+		return -1;
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_LOCK(&skills_groups);
+
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!strcmp(rs->name, ruleset_name))
+			break;
+	}
+
+	if (!rs) {
+		ast_log(LOG_WARNING, "Ruleset '%s' does not exist.\n", ruleset_name);
+	} else {
+		rule_iter = ao2_iterator_init(rs->rules, 0);
 
-	/* Temporarily set realtime  members dead so we can detect deleted ones.*/
-	mem_iter = ao2_iterator_init(q->members, 0);
-	while ((m = ao2_iterator_next(&mem_iter))) {
-		if (m->realtime) {
-			m->dead = 1;
+		/* Clear the current selection (if any) */
+		if (qe->mem_selection) {
+			ao2_ref(qe->mem_selection, -1);
+			qe->mem_selection = NULL;
 		}
-		ao2_ref(m, -1);
-	}
-	ao2_iterator_destroy(&mem_iter);
 
-	while ((interface = ast_category_browse(member_config, interface))) {
-		rt_handle_member_record(q, interface, member_config);
-	}
+		while (!qe->mem_selection && (rule = ao2_iterator_next(&rule_iter))) {
+			qe->mem_selection = ao2_container_alloc(37, member_hash_fn, member_cmp_fn);
+			mem_iter = ao2_iterator_init(q->members, 0);
+			while ((member = ao2_iterator_next(&mem_iter))) {
+				struct skills_group* skills;
+				AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+					if (!strcmp(skills->name, member->skills))
+						break;
+				}
 
-	/* Delete all realtime members that have been deleted in DB. */
-	mem_iter = ao2_iterator_init(q->members, 0);
-	while ((m = ao2_iterator_next(&mem_iter))) {
-		if (m->dead) {
-			if (ast_strlen_zero(m->membername) || !log_membername_as_agent) {
-				ast_queue_log(q->name, "REALTIME", m->interface, "REMOVEMEMBER", "%s", "");
-			} else {
-				ast_queue_log(q->name, "REALTIME", m->membername, "REMOVEMEMBER", "%s", "");
+				if (!skills) {
+					ast_log(LOG_WARNING, "Skills group '%s' does not exist.\n", member->skills);
+					continue;
+				}
+
+				if (!ast_strlen_zero(member->skills) &&
+				    operator_eval_skills(rule->cond, skills, variables, qe)) {
+					ao2_link(qe->mem_selection, member);
+					ast_log(LOG_DEBUG, "Member %s is associated.\n", member->interface);
+				} else
+					ast_log(LOG_DEBUG, "Member %s is NOT associated.\n", member->interface);
+				ao2_ref(member, -1);
 			}
-			member_remove_from_queue(q, m);
+			ao2_iterator_destroy(&mem_iter);
+			if (!ao2_container_count(qe->mem_selection) || (rule->dcond && !operator_eval_dynamics(rule->dcond, variables, qe))) {
+				/* CLEAR to retry. */
+				ast_log(LOG_DEBUG, "Jump to the next rule.\n");
+				ao2_ref(qe->mem_selection, -1);
+				qe->mem_selection = NULL;
+				qe->skills_next_check = 0;
+			}
+			ao2_ref(rule, -1);
 		}
-		ao2_ref(m, -1);
+		ao2_iterator_destroy(&rule_iter);
 	}
-	ao2_iterator_destroy(&mem_iter);
-	ao2_unlock(q);
-	ast_config_destroy(member_config);
+
+	AST_LIST_UNLOCK(&skill_rulesets);
+	AST_LIST_UNLOCK(&skills_groups);
+
+	res = qe->mem_selection == NULL ? 1 : 0;
+	ast_log(LOG_DEBUG, "End of member selection, will return %d\n", res);
+
+	/* 0 only if a rule match. */
+	return res;
+}
+
+static int update_queue_ent_skills_next_check(struct call_queue *q)
+{
+	struct queue_ent* ch = q->head;
+	time_t now = time(NULL);
+	for (; ch; ch = ch->next)
+		ch->skills_next_check = now;
+	return 0;
 }
 
 static int join_queue(char *queuename, struct queue_ent *qe, enum queue_result *reason, int position)
@@ -2909,7 +3916,9 @@ static int join_queue(char *queuename, s
 	/* This is our one */
 	if (q->joinempty) {
 		int status = 0;
-		if ((status = get_member_status(q, qe->max_penalty, qe->min_penalty, q->joinempty))) {
+
+		/* do not give 'qe' because the members selection isn't made yet. */
+		if ((status = get_member_status(q, qe->max_penalty, qe->min_penalty, q->joinempty, NULL))) {
 			*reason = QUEUE_JOINEMPTY;
 			ao2_unlock(q);
 			queue_t_unref(q, "Done with realtime queue");
@@ -2924,6 +3933,10 @@ static int join_queue(char *queuename, s
 		 * Take into account the priority of the calling user */
 		inserted = 0;
 		prev = NULL;
+
+		if (!ast_strlen_zero(qe->skill_ruleset))
+			join_virtual_queue(q, qe);
+
 		cur = q->head;
 		while (cur) {
 			/* We have higher priority than the current user, enter
@@ -2956,6 +3969,7 @@ static int join_queue(char *queuename, s
 		ast_copy_string(qe->announce, q->announce, sizeof(qe->announce));
 		ast_copy_string(qe->context, q->context, sizeof(qe->context));
 		q->count++;
+		update_queue_ent_skills_next_check(q);
 		if (q->count == 1) {
 			ast_devstate_changed(AST_DEVICE_RINGING, AST_DEVSTATE_CACHABLE, "Queue:%s", q->name);
 		}
@@ -3069,7 +4083,7 @@ static int valid_exit(struct queue_ent *
 
 static int say_position(struct queue_ent *qe, int ringing)
 {
-	int res = 0, avgholdmins, avgholdsecs, announceposition = 0;
+	int res = 0, avgholdmins, avgholdsecs, holdtime, announceposition = 0;
 	int say_thanks = 1;
 	time_t now;
 
@@ -3143,11 +4157,12 @@ static int say_position(struct queue_ent
 		}
 	}
 	/* Round hold time to nearest minute */
-	avgholdmins = abs(((qe->parent->holdtime + 30) - (now - qe->start)) / 60);
+	holdtime = get_estimated_waiting_time(qe);
+	avgholdmins = abs(((holdtime + 30) - (now - qe->start)) / 60);
 
 	/* If they have specified a rounding then round the seconds as well */
 	if (qe->parent->roundingseconds) {
-		avgholdsecs = (abs(((qe->parent->holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
+		avgholdsecs = (abs(((holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
 		avgholdsecs *= qe->parent->roundingseconds;
 	} else {
 		avgholdsecs = 0;
@@ -3227,6 +4242,13 @@ playout:
 	return res;
 }
 
+static void recalc_member_holdtime(struct member *mem, int newholdtime)
+{
+	int oldvalue;
+	oldvalue = mem->holdtime;
+	mem->holdtime = (((oldvalue << 2) - oldvalue) + newholdtime) >> 2;
+}
+
 static void recalc_holdtime(struct queue_ent *qe, int newholdtime)
 {
 	int oldvalue;
@@ -3242,7 +4264,7 @@ static void recalc_holdtime(struct queue
 }
 
 /*! \brief Caller leaving queue.
- * 
+ *
  * Search the queue to find the leaving client, if found remove from queue
  * create manager event, move others up the queue.
 */
@@ -3264,6 +4286,8 @@ static void leave_queue(struct queue_ent
 		if (current == qe) {
 			char posstr[20];
 			q->count--;
+			update_queue_ent_skills_next_check(q);
+
 			if (!q->count) {
 				ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s", q->name);
 			}
@@ -3369,9 +4393,10 @@ static void hangupcalls(struct callattem
  * \note The queue passed in should be locked prior to this function call
  *
  * \param[in] q The queue for which we are couting the number of available members
+ * \param[in] qe The queue entry for which we are counting the number of available associated members (can be NULL).
  * \return Return the number of available members in queue q
  */
-static int num_available_members(struct call_queue *q)
+static int num_available_members(struct call_queue *q, struct queue_ent *qe)
 {
 	struct member *mem;
 	int avl = 0;
@@ -3380,7 +4405,7 @@ static int num_available_members(struct
 	mem_iter = ao2_iterator_init(q->members, 0);
 	while ((mem = ao2_iterator_next(&mem_iter))) {
 
-		avl += is_member_available(mem);
+		avl += is_member_available(mem, qe);
 		ao2_ref(mem, -1);
 
 		/* If autofill is not enabled or if the queue's strategy is ringall, then
@@ -3421,7 +4446,7 @@ static int compare_weight(struct call_qu
 		if (q->count && q->members) {
 			if ((mem = ao2_find(q->members, member, OBJ_POINTER))) {
 				ast_debug(1, "Found matching member %s in queue '%s'\n", mem->interface, q->name);
-				if (q->weight > rq->weight && q->count >= num_available_members(q)) {
+				if (q->weight > rq->weight && q->count >= num_available_members(q, NULL)) {
 					ast_debug(1, "Queue '%s' (weight %d, calls %d) is preferred over '%s' (weight %d, calls %d)\n", q->name, q->weight, q->count, rq->name, rq->weight, rq->count);
 					found = 1;
 				}
@@ -3543,7 +4568,7 @@ static int member_call_pending_set(struc
  *
  * \retval non-zero if an entry can be called.
  */
-static int can_ring_entry(struct queue_ent *qe, struct callattempt *call)
+static int can_ring_entry(struct queue_ent *qe, struct callattempt *call, int *busies)
 {
 	if (call->member->paused) {
 		ast_debug(1, "%s paused, can't receive call\n", call->interface);
@@ -3563,6 +4588,13 @@ static int can_ring_entry(struct queue_e
 		return 0;
 	}
 
+	if (!member_is_selected(qe, call->member)) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "%s doesn't match ruleset '%s'\n", call->interface, qe->skill_ruleset);
+		--*busies;
+		return 0;
+	}
+
 	if (use_weight && compare_weight(qe->parent, call->member)) {
 		ast_debug(1, "Priority queue delaying call to %s:%s\n",
 			qe->parent->name, call->interface);
@@ -3592,11 +4624,11 @@ static int can_ring_entry(struct queue_e
 	return 1;
 }
 
-/*! 
+/*!
  * \brief Part 2 of ring_one
  *
- * Does error checking before attempting to request a channel and call a member. 
- * This function is only called from ring_one(). 
+ * Does error checking before attempting to request a channel and call a member.
+ * This function is only called from ring_one().
  * Failure can occur if:
  * - Agent on call
  * - Agent is paused
@@ -3615,7 +4647,7 @@ static int ring_entry(struct queue_ent *
 	const char *macrocontext, *macroexten;
 
 	/* on entry here, we know that tmp->chan == NULL */
-	if (!can_ring_entry(qe, tmp)) {
+	if (!can_ring_entry(qe, tmp, busies)) {
 		if (ast_channel_cdr(qe->chan)) {
 			ast_cdr_busy(ast_channel_cdr(qe->chan));
 		}
@@ -3671,7 +4703,7 @@ static int ring_entry(struct queue_ent *
 		} else if (!ast_strlen_zero(ast_channel_dialed(qe->chan)->number.str)) {
 			ast_set_callerid(tmp->chan, ast_channel_dialed(qe->chan)->number.str, NULL, NULL);
 		} else if (!ast_strlen_zero(S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)))) {
-			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL); 
+			ast_set_callerid(tmp->chan, S_OR(ast_channel_macroexten(qe->chan), ast_channel_exten(qe->chan)), NULL, NULL);
 		}
 		tmp->dial_callerid_absent = 1;
 	}
@@ -3803,7 +4835,7 @@ static struct callattempt *find_best(str
 	return best;
 }
 
-/*! 
+/*!
  * \brief Place a call to a queue member.
  *
  * Once metrics have been calculated for each member, this function is used
@@ -3837,7 +4869,7 @@ static int ring_one(struct queue_ent *qe
 			ast_debug(1, "Trying '%s' with metric %d\n", best->interface, best->metric);
 			ret = ring_entry(qe, best, busies);
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			ast_debug(1, "Queue timed out while ringing members.\n");
@@ -3919,14 +4951,14 @@ static int say_periodic_announcement(str
 	}
 
 	ast_verb(3, "Playing periodic announcement\n");
-	
+
 	if (qe->parent->randomperiodicannounce && qe->parent->numperiodicannounce) {
 		qe->last_periodic_announce_sound = ((unsigned long) ast_random()) % qe->parent->numperiodicannounce;
-	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce || 
+	} else if (qe->last_periodic_announce_sound >= qe->parent->numperiodicannounce ||
 		ast_str_strlen(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]) == 0) {
 		qe->last_periodic_announce_sound = 0;
 	}
-	
+
 	/* play the announcement */
 	res = play_file(qe->chan, ast_str_buffer(qe->parent->sound_periodicannounce[qe->last_periodic_announce_sound]));
 
@@ -3954,7 +4986,7 @@ static int say_periodic_announcement(str
 	if (!qe->parent->randomperiodicannounce) {
 		qe->last_periodic_announce_sound++;
 	}
-	
+
 	return res;
 }
 
@@ -4605,7 +5637,7 @@ skip_frame:;
 	return peer;
 }
 
-/*! 
+/*!
  * \brief Check if we should start attempting to call queue members.
  *
  * A simple process, really. Count the number of members who are available
@@ -4625,21 +5657,21 @@ static int is_our_turn(struct queue_ent
 	/* This needs a lock. How many members are available to be served? */
 	ao2_lock(qe->parent);
 
-	avl = num_available_members(qe->parent);
+	avl = num_available_members(qe->parent, qe);
 
 	ch = qe->parent->head;
 
 	ast_debug(1, "There %s %d available %s.\n", avl != 1 ? "are" : "is", avl, avl != 1 ? "members" : "member");
 
 	while ((idx < avl) && (ch) && (ch != qe)) {
-		if (!ch->pending) {
+		if (!ch->pending && ch->vqueue == qe->vqueue) {
 			idx++;
 		}
-		ch = ch->next;			
+		ch = ch->next;
 	}
 
 	ao2_unlock(qe->parent);
-	/* If the queue entry is within avl [the number of available members] calls from the top ... 
+	/* If the queue entry is within avl [the number of available members] calls from the top ...
 	 * Autofill and position check added to support autofill=no (as only calls
 	 * from the front of the queue are valid when autofill is disabled)
 	 */
@@ -4664,7 +5696,7 @@ static void update_qe_rule(struct queue_
 {
 	int max_penalty = qe->pr->max_relative ? qe->max_penalty + qe->pr->max_value : qe->pr->max_value;
 	int min_penalty = qe->pr->min_relative ? qe->min_penalty + qe->pr->min_value : qe->pr->min_value;
-	char max_penalty_str[20], min_penalty_str[20]; 
+	char max_penalty_str[20], min_penalty_str[20];
 	/* a relative change to the penalty could put it below 0 */
 	if (max_penalty < 0) {
 		max_penalty = 0;
@@ -4715,7 +5747,7 @@ static int wait_our_turn(struct queue_en
 		if (qe->parent->leavewhenempty) {
 			int status = 0;
 
-			if ((status = get_member_status(qe->parent, qe->max_penalty, qe->min_penalty, qe->parent->leavewhenempty))) {
+			if ((status = get_member_status(qe->parent, qe->max_penalty, qe->min_penalty, qe->parent->leavewhenempty, qe))) {
 				*reason = QUEUE_LEAVEEMPTY;
 				ast_queue_log(qe->parent->name, ast_channel_uniqueid(qe->chan), "NONE", "EXITEMPTY", "%d|%d|%ld", qe->pos, qe->opos, (long) time(NULL) - qe->start);
 				leave_queue(qe);
@@ -4739,7 +5771,7 @@ static int wait_our_turn(struct queue_en
 		if (qe->parent->periodicannouncefrequency &&
 			(res = say_periodic_announcement(qe,ringing)))
 			break;
-		
+
 		/* see if we need to move to the next penalty level for this queue */
 		while (qe->pr && ((time(NULL) - qe->start) >= qe->pr->time)) {
 			update_qe_rule(qe);
@@ -4750,7 +5782,7 @@ static int wait_our_turn(struct queue_en
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
-		
+
 		/* Wait a second before checking again */
 		if ((res = ast_waitfordigit(qe->chan, RECHECK * 1000))) {
 			if (res > 0 && !valid_exit(qe, res)) {
@@ -4759,12 +5791,19 @@ static int wait_our_turn(struct queue_en
 				break;
 			}
 		}
-		
+
 		/* If we have timed out, break out */
 		if (qe->expire && (time(NULL) >= qe->expire)) {
 			*reason = QUEUE_TIMEOUT;
 			break;
 		}
+
+		if (qe->skills_next_check && (time(NULL) >= qe->skills_next_check)) {
+			res = select_members_from_skills(qe);
+			if (res == -1) {
+				break;
+			}
+		}
 	}
 
 	return res;
@@ -4802,7 +5841,7 @@ static int update_queue(struct call_queu
 		member->calls++;
 		member->lastqueue = q;
 		ao2_unlock(q);
-	}	
+	}
 	ao2_lock(q);
 	q->callscompleted++;
 	if (callcompletedinsl) {
@@ -5010,7 +6049,7 @@ static void queue_transfer_fixup(void *d
 				(long) (time(NULL) - callstart), qe->opos);
 
 	update_queue(qe->parent, member, callcompletedinsl, (time(NULL) - callstart));
-	
+
 	/* No need to lock the channels because they are already locked in ast_do_masquerade */
 	if ((datastore = ast_channel_datastore_find(old_chan, &queue_transfer_info, NULL))) {
 		ast_channel_datastore_remove(old_chan, datastore);
@@ -5109,7 +6148,7 @@ static void end_bridge_callback(void *da
  * \param[in] qe the queue_ent structure which corresponds to the caller attempting to reach members
  * \param[in] opts the options passed as the third parameter to the Queue() application
  * \param[in] opt_args the options passed as the third parameter to the Queue() application
- * \param[in] announceoverride filename to play to user when waiting 
+ * \param[in] announceoverride filename to play to user when waiting
  * \param[in] url the url passed as the fourth parameter to the Queue() application
  * \param[in,out] tries the number of times we have tried calling queue members
  * \param[out] noption set if the call to Queue() has the 'n' option set.
@@ -5209,7 +6248,7 @@ static int try_calling(struct queue_ent
 		ast_set_flag(&(bridge_config.features_caller), AST_FEATURE_PARKCALL);
 	}
 	if (ast_test_flag(&opts, OPT_NO_RETRY)) {
-		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR 
+		if (qe->parent->strategy == QUEUE_STRATEGY_RRMEMORY || qe->parent->strategy == QUEUE_STRATEGY_LINEAR
 			|| qe->parent->strategy == QUEUE_STRATEGY_RRORDERED) {
 			(*tries)++;
 		} else {
@@ -5290,7 +6329,7 @@ static int try_calling(struct queue_ent
 		AST_LIST_LOCK(dialed_interfaces);
 		AST_LIST_TRAVERSE(dialed_interfaces, di, list) {
 			if (!strcasecmp(cur->interface, di->interface)) {
-				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n", 
+				ast_debug(1, "Skipping dialing interface '%s' since it has already been dialed\n",
 					di->interface);
 				break;
 			}
@@ -5345,7 +6384,7 @@ static int try_calling(struct queue_ent
 			   XXX If we're forcibly removed, these outgoing calls won't get
 			   hung up XXX */
 			tmp->q_next = outgoing;
-			outgoing = tmp;		
+			outgoing = tmp;
 			/* If this line is up, don't try anybody else */
 			if (outgoing->chan && (ast_channel_state(outgoing->chan) == AST_STATE_UP))
 				break;
@@ -5450,6 +6489,7 @@ static int try_calling(struct queue_ent
 		member = lpeer->member;
 		/* Increment the refcount for this member, since we're going to be using it for awhile in here. */
 		ao2_ref(member, 1);
+		recalc_member_holdtime(member, (now - qe->start));
 		hangupcalls(outgoing, peer, qe->cancel_answered_elsewhere);
 		outgoing = NULL;
 		if (announce || qe->parent->reportholdtime || qe->parent->memberdelay) {
@@ -5569,7 +6609,7 @@ static int try_calling(struct queue_ent
 		 	pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-		
+
 		/* if setqueueentryvar is defined, make queue entry (i.e. the caller) variables available to the channel */
 		/* use  pbx_builtin_setvar to set a load of variables with one call */
 		if (qe->parent->setqueueentryvar) {
@@ -5578,7 +6618,7 @@ static int try_calling(struct queue_ent
 			pbx_builtin_setvar_multiple(qe->chan, interfacevar);
 			pbx_builtin_setvar_multiple(peer, interfacevar);
 		}
-	
+
 		ao2_unlock(qe->parent);
 
 		/* try to set queue variables if configured to do so*/
@@ -5622,7 +6662,7 @@ static int try_calling(struct queue_ent
 				}
 			} else {
 				mixmonapp = pbx_findapp("MixMonitor");
-				
+
 				if (mixmonapp) {
 					ast_debug(1, "Starting MixMonitor as requested.\n");
 					if (!monitorfilename) {
@@ -5689,7 +6729,7 @@ static int try_calling(struct queue_ent
 
 						pbx_substitute_variables_helper(qe->chan, meid2, meid, sizeof(meid) - 1);
 					}
-	
+
 					snprintf(tmpid2, sizeof(tmpid2), "%s.%s", tmpid, qe->parent->monfmt);
 
 					if (!ast_strlen_zero(monitor_exec)) {
@@ -5697,7 +6737,7 @@ static int try_calling(struct queue_ent
 					} else {
 						snprintf(mixmonargs, sizeof(mixmonargs), "%s,b%s", tmpid2, monitor_options);
 					}
-					
+
 					ast_debug(1, "Arguments being passed to MixMonitor: %s\n", mixmonargs);
 					/* We purposely lock the CDR so that pbx_exec does not update the application data */
 					if (ast_channel_cdr(qe->chan)) {
@@ -5713,12 +6753,12 @@ static int try_calling(struct queue_ent
 			}
 		}
 		/* Drop out of the queue at this point, to prepare for next caller */
-		leave_queue(qe);			
+		leave_queue(qe);
 		if (!ast_strlen_zero(url) && ast_channel_supports_html(peer)) {
 			ast_debug(1, "app_queue: sendurl=%s.\n", url);
 			ast_channel_sendurl(peer, url);
 		}
-		
+
 		/* run a macro for this connection if defined. The macro simply returns, no action is taken on the result */
 		/* use macro from dialplan if passed as a option, otherwise use the default queue macro */
 		if (!ast_strlen_zero(macro)) {
@@ -5855,7 +6895,7 @@ static int try_calling(struct queue_ent
 					qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		ast_copy_string(oldcontext, ast_channel_context(qe->chan), sizeof(oldcontext));
 		ast_copy_string(oldexten, ast_channel_exten(qe->chan), sizeof(oldexten));
-	
+
 		if ((queue_end_bridge = ao2_alloc(sizeof(*queue_end_bridge), NULL))) {
 			queue_end_bridge->q = qe->parent;
 			queue_end_bridge->chan = qe->chan;
@@ -5896,7 +6936,7 @@ static int try_calling(struct queue_ent
 					(long) (callstart - qe->start), (long) (time(NULL) - callstart), qe->opos);
 				send_agent_complete(qe, queuename, peer, member, callstart, vars, sizeof(vars), AGENT);
 			}
-			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {	
+			if ((tds = ast_channel_datastore_find(qe->chan, &queue_transfer_info, NULL))) {
 				ast_channel_datastore_remove(qe->chan, tds);
 			}
 			ast_channel_unlock(qe->chan);
@@ -5975,7 +7015,7 @@ static struct member *interface_exists(s
 
 /*! \brief Dump all members in a specific queue to the database
  *
- * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>[|...]
+ * <pm_family>/<queuename> = <interface>;<penalty>;<paused>;<state_interface>;<skills>[|...]
  */
 static void dump_queue_members(struct call_queue *pm_queue)
 {
@@ -6000,13 +7040,14 @@ static void dump_queue_members(struct ca
 			continue;
 		}
 
-		ast_str_append(&value, 0, "%s%s;%d;%d;%s;%s",
+		ast_str_append(&value, 0, "%s%s;%d;%d;%s;%s;%s",
 			ast_str_strlen(value) ? "|" : "",
 			cur_member->interface,
 			cur_member->penalty,
 			cur_member->paused,
 			cur_member->membername,
-			cur_member->state_interface);
+			cur_member->state_interface,
+            cur_member->skills);
 
 		ao2_ref(cur_member, -1);
 	}
@@ -6024,7 +7065,7 @@ static void dump_queue_members(struct ca
 	ast_free(value);
 }
 
-/*! \brief Remove member from queue 
+/*! \brief Remove member from queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY removed member from queue
@@ -6036,6 +7077,7 @@ static int remove_from_queue(const char
 		.name = queuename,
 	};
 	struct member *mem, tmpmem;
+	struct queue_ent* qe;
 	int res = RES_NOSUCHQUEUE;
 
 	ast_copy_string(tmpmem.interface, interface, sizeof(tmpmem.interface));
@@ -6072,13 +7114,20 @@ static int remove_from_queue(const char
 				"MemberName: %s\r\n",
 				q->name, mem->interface, mem->membername);
 			member_remove_from_queue(q, mem);
+			update_queue_ent_skills_next_check(q);
+
+			/* Remove member from selection of each callers. */
+			for(qe = q->head; qe; qe = qe->next)
+				if (qe->mem_selection)
+					ao2_unlink(qe->mem_selection, mem);
+
 			ao2_ref(mem, -1);
 
 			if (queue_persistent_members) {
 				dump_queue_members(q);
 			}
 
-			if (!num_available_members(q)) {
+			if (!num_available_members(q, NULL)) {
 				ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 			}
 
@@ -6093,14 +7142,14 @@ static int remove_from_queue(const char
 	return res;
 }
 
-/*! \brief Add member to queue 
+/*! \brief Add member to queue
  * \retval RES_NOT_DYNAMIC when they aren't a RT member
  * \retval RES_NOSUCHQUEUE queue does not exist
  * \retval RES_OKAY added member from queue
  * \retval RES_EXISTS queue exists but no members
  * \retval RES_OUT_OF_MEMORY queue exists but not enough memory to create member
 */
-static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface)
+static int add_to_queue(const char *queuename, const char *interface, const char *membername, int penalty, int paused, int dump, const char *state_interface, const char *skills)
 {
 	struct call_queue *q;
 	struct member *new_member, *old_member;
@@ -6114,10 +7163,11 @@ static int add_to_queue(const char *queu
 
 	ao2_lock(q);
 	if ((old_member = interface_exists(q, interface)) == NULL) {
-		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, q->ringinuse))) {
+		if ((new_member = create_queue_member(interface, membername, penalty, paused, state_interface, q->ringinuse, skills))) {
 			new_member->ringinuse = q->ringinuse;
 			new_member->dynamic = 1;
 			member_add_to_queue(q, new_member);
+            update_queue_ent_skills_next_check(q);
 			/*** DOCUMENTATION
 			<managerEventInstance>
 				<synopsis>Raised when a member is added to the queue.</synopsis>
@@ -6155,7 +7205,7 @@ static int add_to_queue(const char *queu
 				new_member->penalty, new_member->calls, (int) new_member->lastcall,
 				new_member->status, new_member->paused);
 
-			if (is_member_available(new_member)) {
+			if (is_member_available(new_member, NULL)) {
 				ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 			}
 
@@ -6221,13 +7271,14 @@ static int set_member_paused(const char
 					dump_queue_members(q);
 				}
 
-				if (is_member_available(mem)) {
+				if (is_member_available(mem, NULL)) {
 					ast_devstate_changed(AST_DEVICE_NOT_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
-				} else if (!num_available_members(q)) {
+				} else if (!num_available_members(q, NULL)) {
 					ast_devstate_changed(AST_DEVICE_INUSE, AST_DEVSTATE_CACHABLE, "Queue:%s_avail", q->name);
 				}
 
 				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));
+				update_queue_ent_skills_next_check(q);
 
 				/*** DOCUMENTATION
 				<managerEventInstance>
@@ -6512,6 +7563,7 @@ static void reload_queue_members(void)
 	char *member;
 	char *interface;
 	char *membername = NULL;
+	char *skills = NULL;
 	char *state_interface;
 	char *penalty_tok;
 	int penalty = 0;
@@ -6563,6 +7615,7 @@ static void reload_queue_members(void)
 			paused_tok = strsep(&member, ";");
 			membername = strsep(&member, ";");
 			state_interface = strsep(&member, ";");
+			skills = strsep(&member, ";");
 
 			if (!penalty_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (penalty)\n", queue_name);
@@ -6573,7 +7626,7 @@ static void reload_queue_members(void)
 				ast_log(LOG_WARNING, "Error converting penalty: %s: Out of range.\n", penalty_tok);
 				break;
 			}
-			
+
 			if (!paused_tok) {
 				ast_log(LOG_WARNING, "Error parsing persistent member string for '%s' (paused)\n", queue_name);
 				break;
@@ -6585,8 +7638,8 @@ static void reload_queue_members(void)
 			}
 
 			ast_debug(1, "Reload Members: Queue: %s  Member: %s  Name: %s  Penalty: %d  Paused: %d\n", queue_name, interface, membername, penalty, paused);
-			
-			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface) == RES_OUTOFMEMORY) {
+
+			if (add_to_queue(queue_name, interface, membername, penalty, paused, 0, state_interface, skills) == RES_OUTOFMEMORY) {
 				ast_log(LOG_ERROR, "Out of Memory when reloading persistent queue member\n");
 				break;
 			}
@@ -6756,11 +7809,12 @@ static int aqm_exec(struct ast_channel *
 		AST_APP_ARG(options);
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
+		AST_APP_ARG(skills);
 	);
 	int penalty = 0;
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[,interface[,penalty[,options[,membername[,stateinterface]]]]])\n");
+		ast_log(LOG_WARNING, "AddQueueMember requires an argument (queuename[,interface[,penalty[,options[,membername[,stateinterface[,skills]]]]]])\n");
 		return -1;
 	}
 
@@ -6783,7 +7837,7 @@ static int aqm_exec(struct ast_channel *
 		}
 	}
 
-	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface)) {
+	switch (add_to_queue(args.queuename, args.interface, args.membername, penalty, 0, queue_persistent_members, args.state_interface, args.skills)) {
 	case RES_OKAY:
 		if (ast_strlen_zero(args.membername) || !log_membername_as_agent) {
 			ast_queue_log(args.queuename, ast_channel_uniqueid(chan), args.interface, "ADDMEMBER", "%s", "");
@@ -6840,7 +7894,7 @@ static int ql_exec(struct ast_channel *c
 		return -1;
 	}
 
-	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event, 
+	ast_queue_log(args.queuename, args.uniqueid, args.membername, args.event,
 		"%s", args.params ? args.params : "");
 
 	return 0;
@@ -6878,14 +7932,14 @@ static void copy_rules(struct queue_ent
 
 /*!\brief The starting point for all queue calls
  *
- * The process involved here is to 
+ * The process involved here is to
  * 1. Parse the options specified in the call to Queue()
  * 2. Join the queue
  * 3. Wait in a loop until it is our turn to try calling a queue member
  * 4. Attempt to call a queue member
  * 5. If 4. did not result in a bridged call, then check for between
  *    call options such as periodic announcements etc.
- * 6. Try 4 again unless some condition (such as an expiration time) causes us to 
+ * 6. Try 4 again unless some condition (such as an expiration time) causes us to
  *    exit the queue.
  */
 static int queue_exec(struct ast_channel *chan, const char *data)
@@ -6916,6 +7970,7 @@ static int queue_exec(struct ast_channel
 		AST_APP_ARG(gosub);
 		AST_APP_ARG(rule);
 		AST_APP_ARG(position);
+		AST_APP_ARG(skill_ruleset);
 	);
 	/* Our queue entry */
 	struct queue_ent qe = { 0 };
@@ -6923,7 +7978,7 @@ static int queue_exec(struct ast_channel
 	char *opt_args[OPT_ARG_ARRAY_SIZE];
 
 	if (ast_strlen_zero(data)) {
-		ast_log(LOG_WARNING, "Queue requires an argument: queuename[,options[,URL[,announceoverride[,timeout[,agi[,macro[,gosub[,rule[,position]]]]]]]]]\n");
+		ast_log(LOG_WARNING, "Queue requires an argument: queuename[,options[,URL[,announceoverride[,timeout[,agi[,macro[,gosub[,rule[,position[,skill_ruleset]]]]]]]]]]\n");
 		return -1;
 	}
 
@@ -7026,6 +8081,9 @@ static int queue_exec(struct ast_channel
 	qe.prio = prio;
 	qe.max_penalty = max_penalty;
 	qe.min_penalty = min_penalty;
+	if (!ast_strlen_zero(args.skill_ruleset)) {
+		ast_copy_string(qe.skill_ruleset, args.skill_ruleset, sizeof(qe.skill_ruleset));
+	}
 	qe.last_pos_said = 0;
 	qe.last_pos = 0;
 	qe.last_periodic_announce_time = time(NULL);
@@ -7051,6 +8109,18 @@ check_turns:
 		ast_moh_start(chan, qe.moh, NULL);
 	}
 
+	switch (select_members_from_skills(&qe)) {
+	case 1:
+		if (!qe.parent->joinempty || !get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.parent->joinempty, &qe))
+			break;
+		reason = QUEUE_JOINEMPTY;
+	case -1:
+		goto stop;
+		break;
+	default:
+		break;
+	}
+
 	/* This is the wait loop for callers 2 through maxlen */
 	res = wait_our_turn(&qe, ringing, &reason);
 	if (res) {
@@ -7070,7 +8140,7 @@ check_turns:
 			record_abandoned(&qe);
 			reason = QUEUE_TIMEOUT;
 			res = 0;
-			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld", 
+			ast_queue_log(args.queuename, ast_channel_uniqueid(chan),"NONE", "EXITWITHTIMEOUT", "%d|%d|%ld",
 				qe.pos, qe.opos, (long) time(NULL) - qe.start);
 			break;
 		}
@@ -7089,7 +8159,7 @@ check_turns:
 				goto stop;
 			}
 		}
-	
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7112,7 +8182,7 @@ check_turns:
 
 		if (qe.parent->leavewhenempty) {
 			int status = 0;
-			if ((status = get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.parent->leavewhenempty))) {
+			if ((status = get_member_status(qe.parent, qe.max_penalty, qe.min_penalty, qe.parent->leavewhenempty, &qe))) {
 				record_abandoned(&qe);
 				reason = QUEUE_LEAVEEMPTY;
 				ast_queue_log(args.queuename, ast_channel_uniqueid(chan), "NONE", "EXITEMPTY", "%d|%d|%ld", qe.pos, qe.opos, (long)(time(NULL) - qe.start));
@@ -7131,7 +8201,7 @@ check_turns:
 			break;
 		}
 
-		
+
 		/* Leave if we have exceeded our queuetimeout */
 		if (qe.expire && (time(NULL) >= qe.expire)) {
 			record_abandoned(&qe);
@@ -7180,12 +8250,12 @@ stop:
 
 	/* Don't allow return code > 0 */
 	if (res >= 0) {
-		res = 0;	
+		res = 0;
 		if (ringing) {
 			ast_indicate(chan, -1);
 		} else {
 			ast_moh_stop(chan);
-		}			
+		}
 		ast_stopstream(chan);
 	}
 
@@ -7195,6 +8265,16 @@ stop:
 	if (reason != QUEUE_UNKNOWN)
 		set_queue_result(chan, reason);
 
+	if (qe.mem_selection) {
+		ao2_ref(qe.mem_selection, -1);
+	}
+
+	if (qe.vqueue && ao2_ref(qe.vqueue, -1) == 1 && qe.parent) {
+		/* unref vqueue, and if nobody has reference to vqueue except
+		 * the vqueues list, destroy the vqueue object by removing it
+		 * from list. */
+		ao2_unlink(qe.parent->vqueues, qe.vqueue);
+	}
 	/*
 	 * every queue_ent is given a reference to it's parent
 	 * call_queue when it joins the queue.  This ref must be taken
@@ -7474,7 +8554,7 @@ static int queue_function_qac_dep(struct
 		ast_log(LOG_ERROR, "%s requires an argument: queuename\n", cmd);
 		return -1;
 	}
-	
+
 	if ((q = find_load_queue_rt_friendly(data))) {
 		ao2_lock(q);
 		mem_iter = ao2_iterator_init(q->members, 0);
@@ -7608,7 +8688,7 @@ static int queue_function_memberpenalty_
 	}
 
 	penalty = get_member_penalty (args.queuename, args.interface);
-	
+
 	if (penalty >= 0) { /* remember that buf is already '\0' */
 		snprintf (buf, len, "%d", penalty);
 	}
@@ -7704,7 +8784,7 @@ static int reload_queue_rules(int reload
 	char *rulecat = NULL;
 	struct ast_variable *rulevar = NULL;
 	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
-	
+
 	if (!(cfg = ast_config_load("queuerules.conf", config_flags))) {
 		ast_log(LOG_NOTICE, "No queuerules.conf file found, queues will not follow penalty rules\n");
 		return AST_MODULE_LOAD_SUCCESS;
@@ -7744,6 +8824,121 @@ static int reload_queue_rules(int reload
 	return AST_MODULE_LOAD_SUCCESS;
 }
 
+static int reload_queue_skills(int reload)
+{
+	struct ast_config *cfg;
+	char *cat = NULL, *tmp;
+	struct ast_variable *var;
+	struct skills_group *skgrp;
+	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
+
+	if (!(cfg = ast_config_load("queueskills.conf", config_flags))) {
+		ast_log(LOG_NOTICE, "No skills groups config file (queueskills.conf), so no call queues skills\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
+		ast_log(LOG_NOTICE, "queueskills.conf has not changed since it was last loaded. Not taking any action.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_ERROR, "Config file queueskills.conf is in an invalid format.  Aborting.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	}
+	AST_LIST_LOCK(&skills_groups);
+
+	/* Clear current skills */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skills_groups, skgrp, entry) {
+		AST_LIST_REMOVE_CURRENT(entry);
+		ao2_ref(skgrp, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		skgrp = ao2_alloc(sizeof(*skgrp), destroy_skills_group);
+
+		if (!skgrp) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for skills group");
+			break;
+		}
+		ast_copy_string(skgrp->name, cat, sizeof(skgrp->name));
+		skgrp->skills = ao2_container_alloc(37, NULL, NULL);
+
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill* sk;
+			sk = ao2_alloc(sizeof(*sk), NULL);
+			if (!sk) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a skill");
+				break;
+			}
+			ast_copy_string(sk->name, var->name, sizeof(sk->name));
+			tmp = ast_skip_blanks(var->value);
+			sk->weight = atoi(tmp);
+
+			ao2_link(skgrp->skills, sk);
+			ao2_ref(sk, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skills_groups, skgrp, entry);
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+	ast_config_destroy(cfg);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
+static int reload_queue_skill_rules(int reload)
+{
+	struct ast_config *cfg;
+	struct ast_variable *var;
+	struct skill_ruleset *ruleset;
+	char *cat = NULL;
+	struct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };
+
+	if (!(cfg = ast_config_load("queueskillrules.conf", config_flags))) {
+		ast_log(LOG_NOTICE, "No rules config file (queueskillrules.conf), so no call queues rules\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {
+		ast_log(LOG_NOTICE, "queueskillsrules.conf has not changed since it was last loaded. Not taking any action.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	} else if (cfg == CONFIG_STATUS_FILEINVALID) {
+		ast_log(LOG_ERROR, "Config file queueskillsrules.conf is in an invalid format.  Aborting.\n");
+		return AST_MODULE_LOAD_SUCCESS;
+	}
+	AST_LIST_LOCK(&skill_rulesets);
+
+	/* Clear current skill_rulesets */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&skill_rulesets, ruleset, entry) {
+		AST_LIST_REMOVE_CURRENT(entry);
+		ao2_ref(ruleset, -1);
+	}
+	AST_LIST_TRAVERSE_SAFE_END;
+
+	while ((cat = ast_category_browse(cfg, cat))) {
+		ruleset = ao2_alloc(sizeof(*ruleset), destroy_skill_ruleset);
+		if (!ruleset) {
+			ast_log(LOG_WARNING, "Unable to allocate memory for a ruleset.");
+			break;
+		}
+		ast_copy_string(ruleset->name, cat, sizeof(ruleset->name));
+		ruleset->rules = ao2_container_alloc(37, NULL, NULL);
+		for (var = ast_variable_browse(cfg, cat); var; var = var->next) {
+			struct skill_rule *r = ao2_alloc(sizeof(*r), destroy_skill_rule);
+			if (!r) {
+				ast_log(LOG_WARNING, "Unable to allocate memory for a rule.");
+				break;
+			}
+			parse_skill_rule(r, var->value);
+
+			/* check if this rule is empty. */
+			if (r->cond)
+				ao2_link(ruleset->rules, r);
+			ao2_ref(r, -1);
+		}
+
+		AST_LIST_INSERT_HEAD(&skill_rulesets, ruleset, entry);
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+	ast_config_destroy(cfg);
+	return AST_MODULE_LOAD_SUCCESS;
+}
+
 /*! Set the global queue parameters as defined in the "general" section of queues.conf */
 static void queue_set_global_params(struct ast_config *cfg)
 {
@@ -7789,7 +8984,7 @@ static void queue_set_global_params(stru
  */
 static void reload_single_member(const char *memberdata, struct call_queue *q)
 {
-	char *membername, *interface, *state_interface, *tmp;
+	char *membername, *interface, *state_interface, *skills = NULL, *tmp;
 	char *parse;
 	struct member *cur, *newm;
 	struct member tmpmem;
@@ -7801,6 +8996,7 @@ static void reload_single_member(const c
 		AST_APP_ARG(membername);
 		AST_APP_ARG(state_interface);
 		AST_APP_ARG(ringinuse);
+		AST_APP_ARG(skills);
 	);
 
 	if (ast_strlen_zero(memberdata)) {
@@ -7855,11 +9051,15 @@ static void reload_single_member(const c
 		ringinuse = q->ringinuse;
 	}
 
+	if (!ast_strlen_zero(args.skills)) {
+		skills = ast_skip_blanks(args.skills);
+	}
+
 	/* Find the old position in the list */
 	ast_copy_string(tmpmem.interface, interface, sizeof(tmpmem.interface));
 	cur = ao2_find(q->members, &tmpmem, OBJ_POINTER);
 
-	if ((newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, ringinuse))) {
+	if ((newm = create_queue_member(interface, membername, penalty, cur ? cur->paused : 0, state_interface, ringinuse, skills))) {
 		if (cur) {
 			/* Round Robin Queue Position must be copied if this is replacing an existing member */
 			ao2_lock(q->members);
@@ -7874,6 +9074,7 @@ static void reload_single_member(const c
 		ao2_ref(newm, -1);
 	}
 	newm = NULL;
+	update_queue_ent_skills_next_check(q);
 
 	if (cur) {
 		ao2_ref(cur, -1);
@@ -7905,7 +9106,7 @@ static int kill_dead_members(void *obj,
  *
  * Once we have isolated a queue within reload_queues, we call this. This will either
  * reload information for the queue or if we're just reloading member information, we'll just
- * reload that without touching other settings within the queue 
+ * reload that without touching other settings within the queue
  *
  * \param cfg The configuration which we are reading
  * \param mask Tells us what information we need to reload
@@ -7941,7 +9142,7 @@ static void reload_single_queue(struct a
 	} else {
 		new = 0;
 	}
-	
+
 	if (!new) {
 		ao2_lock(q);
 		prev_weight = q->weight ? 1 : 0;
@@ -8060,7 +9261,7 @@ static int kill_dead_queues(void *obj, v
  * \param mask Gives flags telling us what information to actually reload
  * \param queuename If set to a non-zero string, then only reload information from
  * that particular queue. Otherwise inspect all queues
- * \retval -1 Failure occurred 
+ * \retval -1 Failure occurred
  * \retval 0 All clear!
  */
 static int reload_queues(int reload, struct ast_flags *mask, const char *queuename)
@@ -8165,6 +9366,12 @@ static int reload_handler(int reload, st
 	if (ast_test_flag(mask, QUEUE_RELOAD_RULES)) {
 		res |= reload_queue_rules(reload);
 	}
+	if (ast_test_flag(mask, QUEUE_RELOAD_SKILLS)) {
+		res |= reload_queue_skills(reload);
+	}
+	if (ast_test_flag(mask, QUEUE_RELOAD_SKILL_RULES)) {
+		res |= reload_queue_skill_rules(reload);
+	}
 	if (ast_test_flag(mask, QUEUE_RESET_STATS)) {
 		res |= clear_stats(queuename);
 	}
@@ -8184,9 +9391,9 @@ static void do_print(struct mansession *
 	}
 }
 
-/*! 
- * \brief Show queue(s) status and statistics 
- * 
+/*!
+ * \brief Show queue(s) status and statistics
+ *
  * List the queues strategy, calls processed, members logged in,
  * other queue statistics such as avg hold time.
 */
@@ -8292,6 +9499,8 @@ static char *__queues_show(struct manses
 					mem->realtime ? " (realtime)" : "",
 					mem->paused ? " (paused)" : "",
 					ast_devstate2str(mem->status));
+				if (!ast_strlen_zero(mem->skills))
+					ast_str_append(&out, 0, " (skills: %s)", mem->skills);
 				if (mem->calls) {
 					ast_str_append(&out, 0, " has taken %d calls (last was %ld secs ago)",
 						mem->calls, (long) (time(NULL) - mem->lastcall));
@@ -8309,8 +9518,32 @@ static char *__queues_show(struct manses
 			struct queue_ent *qe;
 			int pos = 1;
 
+			if (q->vqueues) {
+				struct virtual_queue *vqueue;
+				struct ao2_iterator iter;
+				iter = ao2_iterator_init(q->vqueues, 0);
+				while ((vqueue = ao2_iterator_next(&iter)))
+				{
+					pos = 1;
+					ast_str_set(&out, 0, "   Virtual queue %s: ", vqueue->id);
+					do_print(s, fd, ast_str_buffer(out));
+					for (qe = q->head; qe; qe = qe->next) {
+						if (qe->vqueue != vqueue)
+							continue;
+						ast_str_set(&out, 0, "      %d. %s (wait: %ld:%2.2ld, prio: %d)",
+							pos++, ast_channel_name(qe->chan), (long) (now - qe->start) / 60,
+							(long) (now - qe->start) % 60, qe->prio);
+						do_print(s, fd, ast_str_buffer(out));
+					}
+					ao2_ref(vqueue, -1);
+				}
+				ao2_iterator_destroy(&iter);
+			}
+
 			do_print(s, fd, "   Callers: ");
 			for (qe = q->head; qe; qe = qe->next) {
+				if (qe->vqueue)
+					continue;
 				ast_str_set(&out, 0, "      %d. %s (wait: %ld:%2.2ld, prio: %d)",
 					pos++, ast_channel_name(qe->chan), (long) (now - qe->start) / 60,
 					(long) (now - qe->start) % 60, qe->prio);
@@ -8334,7 +9567,7 @@ static char *__queues_show(struct manses
 	return CLI_SUCCESS;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param list Space delimited list of words
@@ -8391,11 +9624,11 @@ static int word_in_list(const char *list
 		/* terminating conditions satisfied, word at beginning or separated by ' ' */
 		return 1;
 	}
-	
+
 	return 0;
 }
 
-/*! 
+/*!
  * \brief Check if a given word is in a space-delimited list
  *
  * \param line The line as typed not including the current word being completed
@@ -8461,7 +9694,7 @@ static char *queue_show(struct ast_cli_e
 			"       Provides summary information on a specified queue.\n";
 		return NULL;
 	case CLI_GENERATE:
-		return complete_queue_show(a->line, a->word, a->pos, a->n);	
+		return complete_queue_show(a->line, a->word, a->pos, a->n);
 	}
 
 	return __queues_show(NULL, a->fd, a->argc, a->argv);
@@ -8577,7 +9810,7 @@ static int manager_queues_summary(struct
 				"LoggedIn: %d\r\n"
 				"Available: %d\r\n"
 				"Talking: %d\r\n"
-				"Callers: %d\r\n" 
+				"Callers: %d\r\n"
 				"HoldTime: %d\r\n"
 				"TalkTime: %d\r\n"
 				"LongestHoldTime: %d\r\n"
@@ -8657,10 +9890,11 @@ static int manager_queues_status(struct
 						"LastCall: %d\r\n"
 						"Status: %d\r\n"
 						"Paused: %d\r\n"
+						"Skills: %s\r\n"
 						"%s"
 						"\r\n",
 						q->name, mem->membername, mem->interface, mem->state_interface, mem->dynamic ? "dynamic" : "static",
-						mem->penalty, mem->calls, (int)mem->lastcall, mem->status, mem->paused, idText);
+						mem->penalty, mem->calls, (int)mem->lastcall, mem->status, mem->paused, mem->skills, idText);
 				}
 				ao2_ref(mem, -1);
 			}
@@ -8703,7 +9937,7 @@ static int manager_queues_status(struct
 
 static int manager_add_queue_member(struct mansession *s, const struct message *m)
 {
-	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface;
+	const char *queuename, *interface, *penalty_s, *paused_s, *membername, *state_interface, *skills;
 	int paused, penalty = 0;
 
 	queuename = astman_get_header(m, "Queue");
@@ -8712,6 +9946,7 @@ static int manager_add_queue_member(stru
 	paused_s = astman_get_header(m, "Paused");
 	membername = astman_get_header(m, "MemberName");
 	state_interface = astman_get_header(m, "StateInterface");
+	skills = astman_get_header(m, "Skills");
 
 	if (ast_strlen_zero(queuename)) {
 		astman_send_error(s, m, "'Queue' not specified.");
@@ -8735,7 +9970,7 @@ static int manager_add_queue_member(stru
 		paused = abs(ast_true(paused_s));
 	}
 
-	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface)) {
+	switch (add_to_queue(queuename, interface, membername, penalty, paused, queue_persistent_members, state_interface, skills)) {
 	case RES_OKAY:
 		if (ast_strlen_zero(membername) || !log_membername_as_agent) {
 			ast_queue_log(queuename, "MANAGER", interface, "ADDMEMBER", "%s", paused ? "PAUSED" : "");
@@ -8866,6 +10101,14 @@ static int manager_queue_reload(struct m
 		ast_set_flag(&mask, QUEUE_RELOAD_RULES);
 		header_found = 1;
 	}
+	if (!strcasecmp(S_OR(astman_get_header(m, "Skills"), ""), "yes")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILLS);
+		header_found = 1;
+	}
+	if (!strcasecmp(S_OR(astman_get_header(m, "SkillRules"), ""), "yes")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILL_RULES);
+		header_found = 1;
+	}
 	if (!strcasecmp(S_OR(astman_get_header(m, "Parameters"), ""), "yes")) {
 		ast_set_flag(&mask, QUEUE_RELOAD_PARAMETERS);
 		header_found = 1;
@@ -8887,7 +10130,7 @@ static int manager_queue_reset(struct ma
 {
 	const char *queuename = NULL;
 	struct ast_flags mask = {QUEUE_RESET_STATS,};
-	
+
 	queuename = astman_get_header(m, "Queue");
 
 	if (!reload_handler(1, &mask, queuename)) {
@@ -8977,7 +10220,7 @@ static int manager_queue_member_penalty(
 		astman_send_error(s, m, "Need 'Interface' and 'Penalty' parameters.");
 		return 0;
 	}
- 
+
 	penalty = atoi(penalty_s);
 
 	if (set_member_value((char *)queuename, (char *)interface, MEMBER_PENALTY, penalty)) {
@@ -8991,7 +10234,7 @@ static int manager_queue_member_penalty(
 
 static char *handle_queue_add_member(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
 {
-	const char *queuename, *interface, *membername = NULL, *state_interface = NULL;
+	const char *queuename, *interface, *membername = NULL, *state_interface = NULL, *skills = NULL;
 	int penalty;
 
 	switch ( cmd ) {
@@ -9005,7 +10248,7 @@ static char *handle_queue_add_member(str
 		return complete_queue_add_member(a->line, a->word, a->pos, a->n);
 	}
 
-	if ((a->argc != 6) && (a->argc != 8) && (a->argc != 10) && (a->argc != 12)) {
+	if ((a->argc != 6) && (a->argc != 8) && (a->argc != 10) && (a->argc != 12) && (a->argc != 14)) {
 		return CLI_SHOWUSAGE;
 	} else if (strcmp(a->argv[4], "to")) {
 		return CLI_SHOWUSAGE;
@@ -9015,6 +10258,8 @@ static char *handle_queue_add_member(str
 		return CLI_SHOWUSAGE;
 	} else if ((a->argc == 12) && strcmp(a->argv[10], "state_interface")) {
 		return CLI_SHOWUSAGE;
+	} else if ((a->argc == 14) && strcmp(a->argv[12], "skills")) {
+		return CLI_SHOWUSAGE;
 	}
 
 	queuename = a->argv[5];
@@ -9041,7 +10286,11 @@ static char *handle_queue_add_member(str
 		state_interface = a->argv[11];
 	}
 
-	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface)) {
+	if (a->argc >= 14) {
+		skills = a->argv[13];
+	}
+
+	switch (add_to_queue(queuename, interface, membername, penalty, 0, queue_persistent_members, state_interface, skills)) {
 	case RES_OKAY:
 		if (ast_strlen_zero(membername) || !log_membername_as_agent) {
 			ast_queue_log(queuename, "CLI", interface, "ADDMEMBER", "%s", "");
@@ -9199,7 +10448,7 @@ static char *handle_queue_pause_member(s
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue {pause|unpause} member";
-		e->usage = 
+		e->usage =
 			"Usage: queue {pause|unpause} member <member> [queue <queue> [reason <reason>]]\n"
 			"	Pause or unpause a queue member. Not specifying a particular queue\n"
 			"	will pause or unpause a member across all queues to which the member\n"
@@ -9334,7 +10583,7 @@ static char *handle_queue_set_member_pen
 	switch (cmd) {
 	case CLI_INIT:
 		e->command = "queue set penalty";
-		e->usage = 
+		e->usage =
 		"Usage: queue set penalty <penalty> on <interface> [in <queue>]\n"
 		"	Set a member's penalty in the queue specified. If no queue is specified\n"
 		"	then that interface's penalty is set in all queues to which that interface is a member\n";
@@ -9367,7 +10616,7 @@ static char *handle_queue_set_member_pen
 	}
 }
 
-static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state) 
+static char *complete_queue_rule_show(const char *line, const char *word, int pos, int state)
 {
 	int which = 0;
 	struct rule_list *rl_iter;
@@ -9421,7 +10670,148 @@ static char *handle_queue_rule_show(stru
 		}
 	}
 	AST_LIST_UNLOCK(&rule_lists);
-	return CLI_SUCCESS; 
+	return CLI_SUCCESS;
+}
+
+static char *complete_queue_skills_groups(const char *line, const char *word, int pos, int state)
+{
+	int which = 0;
+	struct skills_group *skills;
+	int wordlen = strlen(word);
+	char *ret = NULL;
+	if (pos != 4) /* Wha? */ {
+		return NULL;
+	}
+
+	AST_LIST_LOCK(&skills_groups);
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (!strncasecmp(word, skills->name, wordlen) && ++which > state) {
+			ret = ast_strdup(skills->name);
+			break;
+		}
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+
+	return ret;
+}
+
+static char *handle_queue_skills_groups(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	const char *name;
+	struct skills_group *skills;
+	struct skill *skill;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "queue show skills groups";
+		e->usage =
+		"Usage: queue show skills groups [groupname]\n"
+		"	Show the list of skills associated to the group name. If no\n"
+		"	groupname is specified, list all skill groups\n";
+		return NULL;
+	case CLI_GENERATE:
+		return complete_queue_skills_groups(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc != 3 && a->argc != 4 && a->argc != 5)
+		return CLI_SHOWUSAGE;
+
+	name = a->argc == 5 ? a->argv[4] : "";
+
+	AST_LIST_LOCK(&skills_groups);
+	AST_LIST_TRAVERSE(&skills_groups, skills, entry) {
+		if (!name || !strcmp(skills->name, name)) {
+			struct ao2_iterator iter = ao2_iterator_init(skills->skills, 0);
+			if (name) {
+				ast_cli(a->fd, "Skill group '%s':\n", skills->name);
+			} else {
+				ast_cli(a->fd, "  - %-15s: ", skills->name);
+			}
+
+			while ((skill = ao2_iterator_next(&iter))) {
+				if (name) {
+					ast_cli(a->fd, "  - %-15s: %d\n", skill->name, skill->weight);
+				} else {
+					ast_cli(a->fd, "%s=%d ", skill->name, skill->weight);
+				}
+				ao2_ref(skill, -1);
+			}
+			ast_cli(a->fd, "\n");
+			ao2_iterator_destroy(&iter);
+		}
+	}
+	AST_LIST_UNLOCK(&skills_groups);
+	return CLI_SUCCESS;
+}
+
+static char *complete_queue_skills_rules(const char *line, const char *word, int pos, int state)
+{
+	int which = 0;
+	struct skill_ruleset *rs;
+	int wordlen = strlen(word);
+	char *ret = NULL;
+	if (pos != 4) /* Wha? */ {
+		return NULL;
+	}
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!strncasecmp(word, rs->name, wordlen) && ++which > state) {
+			ret = ast_strdup(rs->name);
+			break;
+		}
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+
+	return ret;
+}
+
+static char *handle_queue_skills_rules(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
+{
+	const char *name;
+	struct skill_ruleset *rs;
+	struct skill_rule *rule;
+
+	switch (cmd) {
+	case CLI_INIT:
+		e->command = "queue show skills rules";
+		e->usage =
+		"Usage: queue show skills rules [rulename]\n"
+		"	Show the list of rules associated to the ruleset name. If no\n"
+		"	rulename is specified, list all rulesets\n";
+		return NULL;
+	case CLI_GENERATE:
+		return complete_queue_skills_rules(a->line, a->word, a->pos, a->n);
+	}
+
+	if (a->argc != 3 && a->argc != 4 && a->argc != 5)
+		return CLI_SHOWUSAGE;
+
+	name = a->argc == 5 ? a->argv[4] : "";
+
+	AST_LIST_LOCK(&skill_rulesets);
+	AST_LIST_TRAVERSE(&skill_rulesets, rs, entry) {
+		if (!name || !strcmp(rs->name, name)) {
+			struct ao2_iterator iter = ao2_iterator_init(rs->rules, 0);
+
+			ast_cli(a->fd, "Skill rules '%s':\n", rs->name);
+			while ((rule = ao2_iterator_next(&iter))) {
+				char *cond = display_operator(rule->cond);
+				if (rule->dcond) {
+					char *dcond = display_operator(rule->dcond);
+					ast_cli(a->fd, "  => [%s] %s\n", dcond, cond);
+					ast_free(dcond);
+				}
+				else
+					ast_cli(a->fd, "  => %s\n", cond);
+				ast_free(cond);
+				ao2_ref(rule, -1);
+			}
+			ao2_iterator_destroy(&iter);
+		}
+	}
+	AST_LIST_UNLOCK(&skill_rulesets);
+	return CLI_SUCCESS;
 }
 
 static char *handle_queue_reset(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
@@ -9511,6 +10901,10 @@ static char *handle_queue_reload(struct
 		ast_set_flag(&mask, QUEUE_RELOAD_MEMBER);
 	} else if (!strcasecmp(a->argv[2], "parameters")) {
 		ast_set_flag(&mask, QUEUE_RELOAD_PARAMETERS);
+	} else if (!strcasecmp(a->argv[2], "skills")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILLS);
+	} else if (!strcasecmp(a->argv[2], "skillrules")) {
+		ast_set_flag(&mask, QUEUE_RELOAD_SKILL_RULES);
 	} else if (!strcasecmp(a->argv[2], "all")) {
 		ast_set_flag(&mask, AST_FLAGS_ALL);
 	}
@@ -9527,7 +10921,7 @@ static char *handle_queue_reload(struct
 	return CLI_SUCCESS;
 }
 
-static const char qpm_cmd_usage[] = 
+static const char qpm_cmd_usage[] =
 "Usage: queue pause member <channel> in <queue> reason <reason>\n";
 
 static const char qum_cmd_usage[] =
@@ -9546,6 +10940,8 @@ static struct ast_cli_entry cli_queue[]
 	AST_CLI_DEFINE(handle_queue_set_member_ringinuse, "Set ringinuse for a channel of a specified queue"),
 	AST_CLI_DEFINE(handle_queue_reload, "Reload queues, members, queue rules, or parameters"),
 	AST_CLI_DEFINE(handle_queue_reset, "Reset statistics for a queue"),
+	AST_CLI_DEFINE(handle_queue_skills_groups, "Show the skills groups defined in queueskills.conf"),
+	AST_CLI_DEFINE(handle_queue_skills_rules, "Show the skills rules defined in queueskillrules.conf"),
 };
 
 /* struct call_queue astdata mapping. */
@@ -9608,6 +11004,7 @@ static struct ast_cli_entry cli_queue[]
 	MEMBER(call_queue, rrpos, AST_DATA_INTEGER)			\
 	MEMBER(call_queue, memberdelay, AST_DATA_INTEGER)		\
 	MEMBER(call_queue, autofill, AST_DATA_INTEGER)			\
+	MEMBER(call_queue, vqueues, AST_DATA_CONTAINER)			\
 	MEMBER(call_queue, members, AST_DATA_CONTAINER)
 
 AST_DATA_STRUCTURE(call_queue, DATA_EXPORT_CALL_QUEUE);
@@ -9617,6 +11014,7 @@ AST_DATA_STRUCTURE(call_queue, DATA_EXPO
 	MEMBER(member, interface, AST_DATA_STRING)			\
 	MEMBER(member, state_interface, AST_DATA_STRING)		\
 	MEMBER(member, membername, AST_DATA_STRING)			\
+	MEMBER(member, skills, AST_DATA_STRING)				\
 	MEMBER(member, penalty, AST_DATA_INTEGER)			\
 	MEMBER(member, calls, AST_DATA_INTEGER)				\
 	MEMBER(member, dynamic, AST_DATA_INTEGER)			\
@@ -9646,6 +11044,7 @@ AST_DATA_STRUCTURE(member, DATA_EXPORT_M
 	MEMBER(queue_ent, min_penalty, AST_DATA_INTEGER)			\
 	MEMBER(queue_ent, linpos, AST_DATA_INTEGER)				\
 	MEMBER(queue_ent, linwrapped, AST_DATA_INTEGER)				\
+	MEMBER(queue_ent, skill_ruleset, AST_DATA_STRING)			\
 	MEMBER(queue_ent, start, AST_DATA_INTEGER)				\
 	MEMBER(queue_ent, expire, AST_DATA_INTEGER)				\
 	MEMBER(queue_ent, cancel_answered_elsewhere, AST_DATA_INTEGER)
Index: asterisk-11.3.0/configs/queueskillrules.conf.sample
===================================================================
--- /dev/null
+++ asterisk-11.3.0/configs/queueskillrules.conf.sample
@@ -0,0 +1,67 @@
+; This file describes skill routing rules. The Queue() application can get the
+; 'skill_ruleset' argument which is the name of one skill routing ruleset. If
+; set, a selection of queue members is defined by running these rules on each
+; member, based on skills set (see the queueskills.conf file).
+;
+; A ruleset is a list of rules. Each rule has two parts:
+;     - the first part is a dynamical condition. If its evaluation is false, the
+;       next rule is tried;
+;     - the second part is tested against queue member's skills, to define a
+;       selection.
+;
+; Operators:
+; ----------
+;
+; You can define these rules with some arithmetic and logical operators:
+;      operand1 / operand2  (division)
+;      operand1 * operand2  (multiplication)
+;      operand1 - operand2  (subtraction)
+;      operand1 + operand2  (addition)
+;      operand1 ! operand2  (is not equal)
+;      operand1 = operand2  (is equal)
+;      operand1 > operand2  (is greater than)
+;      operand1 < operand2  (is lesser than)
+;      operand1 & operand2  (both are true)
+;      operand1 | operand2  (at least one of them are true)
+;
+; '/' is the operator with the higher priority, and '|' the one with the lower
+; priority. You can use brackets '()' to overload operator priorities.
+;
+; Dynamical part:
+; ---------------
+; The first part is evaluated after create a selection of queue members with
+; the second part, and determine if we keep this rule or if we switch to the
+; next one.
+;
+; On this part, these variables can be used:
+;     EWT (Estimated Waiting Time)      The waiting time estimated for the
+;                                       current selection of members
+;     WT  (Waiting time)                The time that caller has been waited
+;
+; Skills part:
+; ------------
+; This second part is evaluated against every queue member's skills, to know
+; if it is selected or not.
+;
+; Variables are skills names, which you can check with below operators. You can
+; also use meta-variables, started with a '$', to substitute them with data set
+; on the Queue() call. For example, if you call Queue() with the skill rouleset
+; argument equal to:
+;      tech(os=linux)
+; every $os occurrence will be replaced to 'linux'.
+;
+; Examples:
+; ---------
+;
+; [tech]
+; rule => WT < 60, technic & ($os > 29 & $lang > 39 | $os > 39 & $lang > 19)
+; rule => WT < 120, technic & ($os > 19 & $lang > 39 | $os > 29 & $lang > 19)
+; rule => WT < 3600, technic & $os > 10 & $lang > 19
+; rule => technic
+;
+; [client-crappy]
+; rule => technic = 0 & (sympathy > 20 | linux > 10 & windows > 10)
+;
+; [client-cool]
+; rule => EWT < 120, technic = 0 & (sympathy > 60)
+; rule => technic = 0
Index: asterisk-11.3.0/configs/queueskills.conf.sample
===================================================================
--- /dev/null
+++ asterisk-11.3.0/configs/queueskills.conf.sample
@@ -0,0 +1,46 @@
+; Describe skills groups here to assign them to queue members. You can set
+; weight to each skills. It'll be used by skill rules to know if a queue member
+; can answer to a call.
+; See the queueskillrules.conf to get more information about these rules.
+;
+; Examples:
+;
+; [linux1]
+; technic = 1
+; linux = 50
+; windows = 10
+; french = 50
+; english = 10
+;
+; [linux2]
+; technic = 1
+; linux = 30
+; windows = 20
+; french = 50
+; english = 50
+;
+; [windows1]
+; technic = 1
+; linux = 10
+; windows = 50
+; french = 30
+; english = 30
+;
+; [windows2]
+; technic = 1
+; linux = 20
+; windows = 30
+; french = 40
+; english = 10
+;
+; [commercial1]
+; technic = 0
+; linux = 10
+; windows = 20
+; sympathy = 100
+;
+; [commercial2]
+; technic = 0
+; linux = 0
+; windows = 20
+; sympathy = 50
